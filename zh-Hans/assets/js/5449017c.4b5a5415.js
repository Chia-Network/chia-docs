"use strict";(globalThis.webpackChunkchia_docs=globalThis.webpackChunkchia_docs||[]).push([[6782],{5644(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"chia-blockchain/architecture/mempool","title":"Mempool","description":"The mempool (or memory pool) is a collection of transactions stored by full nodes, usually in memory, before they are confirmed on the blockchain. The mempool is not dictated by the consensus rules; a farmer can change how their mempool functions and customize the rules without permission from other full nodes.","source":"@site/i18n/zh-Hans/docusaurus-plugin-content-docs/current/chia-blockchain/architecture/mempool.md","sourceDirName":"chia-blockchain/architecture","slug":"/chia-blockchain/architecture/mempool","permalink":"/zh-Hans/chia-blockchain/architecture/mempool","draft":false,"unlisted":false,"editUrl":"https://github.com/Chia-Network/chia-docs/blob/main/docs/chia-blockchain/architecture/mempool.md","tags":[],"version":"current","frontMatter":{"title":"Mempool","slug":"/chia-blockchain/architecture/mempool"},"sidebar":"tutorialSidebar","previous":{"title":"Light Clients","permalink":"/zh-Hans/chia-blockchain/architecture/light-clients"},"next":{"title":"Consensus Introduction","permalink":"/zh-Hans/chia-blockchain/consensus/consensus-intro"}}');var t=i(4848),a=i(8453);const s={title:"Mempool",slug:"/chia-blockchain/architecture/mempool"},r=void 0,l={},c=[{value:"Validation",id:"validation",level:2},{value:"Transaction Deduplication",id:"transaction-deduplication",level:3},{value:"Fee Required for Inclusion",id:"fee-required-for-inclusion",level:2},{value:"Scenario 1: Mempool Not Busy",id:"scenario-1-mempool-not-busy",level:3},{value:"Scenario 2: Mempool Busy But Not Full",id:"scenario-2-mempool-busy-but-not-full",level:3},{value:"Scenario 3: Mempool Full",id:"scenario-3-mempool-full",level:3},{value:"Scenario 4: Mempool Full of Transactions with Fees",id:"scenario-4-mempool-full-of-transactions-with-fees",level:3},{value:"Fast Forward Processing",id:"fast-forward-processing",level:3},{value:"Replace by Fee",id:"replace-by-fee",level:2},{value:"Block Creation",id:"block-creation",level:2},{value:"Enhanced Block Creation (Chia 2.5.5+)",id:"enhanced-block-creation-chia-255",level:3},{value:"Updating the Mempool",id:"updating-the-mempool",level:2},{value:"Schema Changes and Migration (Chia 2.5.5+)",id:"schema-changes-and-migration-chia-255",level:2},{value:"Backwards Incompatible Changes",id:"backwards-incompatible-changes",level:3},{value:"Migration Notes",id:"migration-notes",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"The mempool (or memory pool) is a collection of transactions stored by full nodes, usually in memory, before they are confirmed on the blockchain. The mempool is not dictated by the consensus rules; a farmer can change how their mempool functions and customize the rules without permission from other full nodes."}),"\n",(0,t.jsx)(n.p,{children:"The mempool is a required facet of Chia due to the decentralized nature of the blockchain. Transaction blocks occur approximately every 52 seconds, and it's impossible to predict who will win a block. Therefore, all transactions must be broadcast to the whole network and stored locally until they are confirmed. Additionally, it is normal to have more pending transactions than can fit in a single block, so the mempool also acts as a queue for inclusion into the blockchain."}),"\n",(0,t.jsxs)(n.p,{children:["For more information about the mempool, see our ",(0,t.jsx)(n.a,{href:"https://www.chia.net/2024/01/12/getting-to-know-the-mempool-and-transaction-fees/",children:"blog post"})," on this subject."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:'How many transactions can fit into a block? Due to the varying size of transactions, and the different definitions of what even counts as a "transaction," there is not an exact number. But just for a bit of rough guidance, approximately 1000 transactions with two inputs and two outputs, or 2000 transactions with one input and one output can fit into a single block.'})}),"\n",(0,t.jsx)(n.p,{children:"When a user makes a transaction, it gets sent to a full node, which then verifies it, adds it to the mempool, and broadcasts it to all of its peers. Therefore, transactions get propagated to the whole network in a very short period of time."}),"\n",(0,t.jsx)(n.h2,{id:"validation",children:"Validation"}),"\n",(0,t.jsx)(n.p,{children:"Only valid transactions are allowed to enter the mempool. The process of validating transactions is similar to the process of validating blocks. This includes running CLVM, checking conditions, validating signatures, and checking that the coins to be spent are currently unspent and valid."}),"\n",(0,t.jsx)(n.p,{children:"The transaction is also checked against other transactions in the mempool, to ensure there are no conflicts."}),"\n",(0,t.jsx)(n.h3,{id:"transaction-deduplication",children:"Transaction Deduplication"}),"\n",(0,t.jsx)(n.p,{children:"Starting in Chia 2.5.5, the mempool automatically detects and deduplicates identical spend transactions. When multiple transactions attempt to spend the same coin with identical parameters, only one will be kept in the mempool, reducing memory usage and improving overall performance."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Behavior"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Identical spend transactions are automatically deduplicated"}),"\n",(0,t.jsx)(n.li,{children:"The transaction with the highest fee is prioritized"}),"\n",(0,t.jsx)(n.li,{children:"Duplicate transactions are rejected with appropriate error messages"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"fee-required-for-inclusion",children:"Fee Required for Inclusion"}),"\n",(0,t.jsx)(n.p,{children:"When you submit a transaction, one of several possible scenarios will play out, depending on how full the mempool is, how large of a fee was included, the CLVM cost of the transaction, and other factors. Keep in mind that each farmer has its own copy of the mempool, with its own set of rules. The default mempool behavior discussed in this section will apply to most, but not all, nodes. It is up to each individual farmer to decide which transactions to include upon creating a block."}),"\n",(0,t.jsxs)(n.p,{children:["To view the current status of the mempool, see the dashboard for ",(0,t.jsx)(n.a,{href:"https://dashboard.chia.net/d/46EAA05E/mempool-transactions-and-fees?orgId=1&var-network=mainnet",children:"mainnet"})," and ",(0,t.jsx)(n.a,{href:"https://dashboard.chia.net/d/46EAA05E/mempool-transactions-and-fees?orgId=1&var-network=testnet11",children:"testnet11"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"By default, the total size of the mempool is 20 blocks. This true for both mainnet and testnet11."}),"\n",(0,t.jsx)(n.li,{children:"Prior to version 2.2, the block size was artificially capped at 50% of its capacity."}),"\n",(0,t.jsx)(n.li,{children:"Starting in version 2.2, the block size cap was increased to 60%."}),"\n",(0,t.jsx)(n.li,{children:"This limitation will be increased gradually, until it reaches 100%, or 11 billion cost -- the limit enforced by the consensus rules."}),"\n",(0,t.jsxs)(n.li,{children:["The size (in CLVM cost) of the mempool is ",(0,t.jsx)(n.code,{children:"mempool blocks * max cost per block * block size limit"}),".","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["In version 2.2, this amounts to ",(0,t.jsx)(n.code,{children:"20 * 11 billion * 0.6"}),", which equals 132 billion."]}),"\n",(0,t.jsxs)(n.li,{children:["When the block limiter is lifted, the total size will be ",(0,t.jsx)(n.code,{children:"20 * 11 billion"}),", or 220 billion."]}),"\n"]}),"\n"]}),"\n"]})}),"\n",(0,t.jsx)(n.h3,{id:"scenario-1-mempool-not-busy",children:"Scenario 1: Mempool Not Busy"}),"\n",(0,t.jsx)(n.p,{children:"If the transaction you just submitted -- plus the entire contents of the mempool -- can fit into one block, then your transaction will be added to the next block. This is true even if you don't include a transaction fee. This is true even if you don't include a transaction fee."}),"\n",(0,t.jsxs)(n.p,{children:["The reason for this is straightforward -- the farmer has nothing to gain by excluding certain transactions, so it will include everything. Note that some proprietary software takes the opposite approach: the farmer will ",(0,t.jsx)(n.em,{children:"only"})," include transactions that pay a fee, regardless of mempool size."]}),"\n",(0,t.jsx)(n.p,{children:"The mempool for Chia's mainnet is often in this state. This does not mean that no transactions are being submitted. It simply means that the network's speed of around 20 transactions per second is sufficient to keep up with demand."}),"\n",(0,t.jsx)(n.h3,{id:"scenario-2-mempool-busy-but-not-full",children:"Scenario 2: Mempool Busy But Not Full"}),"\n",(0,t.jsxs)(n.p,{children:["If the mempool's contents will occupy more than one block, but the mempool is not full, then it is considered ",(0,t.jsx)(n.em,{children:"busy"}),". In this case:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'Transactions that don\'t include fees will be added to the mempool, but they won\'t make it into the next block. Instead, they will have to "wait in line" for higher-priority transactions to be cleared. They likely will eventually be included in a block, but this is not guaranteed. Instead, they will have to "wait in line" for higher-priority transactions to be cleared. They likely will eventually be included in a block, but this is not guaranteed.'}),"\n",(0,t.jsx)(n.li,{children:"Transactions with fees will be added to the mempool and prioritized according to the size of their fee-per-cost. Transactions with fees will be added to the mempool and prioritized according to the size of their fee-per-cost. For example, a transaction with a 1-mojo fee will enter the queue ahead of zero-fee transactions."}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{title:"Testnet11 info",type:"info",children:(0,t.jsx)(n.p,{children:"Testnet10 is constantly being \"dusted\" (thousands of small transactions are being included) in order to simulate a busy network, which can be useful for testing. The dust transactions do not include any fees, so in order for your transaction to be prioritized ahead of the dust, you simply have to include a 1-mojo fee. In this case, your transaction will likely be included in the next transaction block. However, if you don't include a fee, it will likely need to wait ~40-60 minutes before being included. The dust transactions do not include any fees, so in order for your transaction to be prioritized ahead of the dust, you simply have to include a 1-mojo fee. In this case, your transaction will likely be included in the next transaction block. However, if you don't include a fee, it will likely need to wait ~40-60 minutes before being included."})}),"\n",(0,t.jsx)(n.h3,{id:"scenario-3-mempool-full",children:"Scenario 3: Mempool Full"}),"\n",(0,t.jsx)(n.p,{children:"If the mempool is completely full, then in order for your transaction to be added, it will need to kick out one or more transactions. In this scenario: In this scenario:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Transactions with no fee will not be added to the mempool."}),"\n",(0,t.jsx)(n.li,{children:"Transactions with a fee of less than five mojos per cost (~100 million mojos for 2-input, 2-output transactions) will be treated as zero-fee transactions, i.e. they will not be added to the mempool."}),"\n",(0,t.jsxs)(n.li,{children:["Transactions with a fee of at least five mojos per cost will be added to the mempool, prioritized by fee-per-cost, ",(0,t.jsx)(n.em,{children:"if"})," they are not the lowest priority transactions (see Scenario 4 in this case)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This scenario often occurs on testnet11. This scenario often occurs on testnet10. When the mempool is completely full, the dusters stop submitting transactions until some of the dust has been cleared. This scenario might occasionally happen on mainnet as well, in which case a minimum fee would be required. This scenario might occasionally happen on mainnet as well, in which case a minimum fee would be required."}),"\n",(0,t.jsxs)(n.p,{children:["If you see ",(0,t.jsx)(n.code,{children:"INVALID_FEE_TOO_CLOSE_TO_ZERO"})," in your log file, the mempool was likely full when you submitted your transaction, and you did not include a sufficient fee to kick out an existing transaction. Try resubmitting your transaction with a higher fee."]}),"\n",(0,t.jsx)(n.h3,{id:"scenario-4-mempool-full-of-transactions-with-fees",children:"Scenario 4: Mempool Full of Transactions with Fees"}),"\n",(0,t.jsx)(n.p,{children:"This is the final scenario, where every transaction in the mempool has a fee of at least five mojos per cost. In order for your transaction to be added, it will need to kick out one or more transactions. In this scenario:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Transactions with no fee will not be added to the mempool."}),"\n",(0,t.jsx)(n.li,{children:"Transactions with a fee of less than five mojos per cost (~100 million mojos for 2-input, 2-output transactions) will be treated as zero-fee transactions, i.e. they will not be added to the mempool."}),"\n",(0,t.jsxs)(n.li,{children:["Transactions with a fee of at least five mojos per cost ",(0,t.jsx)(n.em,{children:"might"})," be added to mempool. For this to happen, they will need to kick out one or more transactions with a lower fee-per-cost ratio. For example:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'If the "cheapest" transaction currently in the mempool has a fee per cost of 10, and your transaction\'s fee per cost is 9, then your transaction will not be added to the mempool.'}),"\n",(0,t.jsx)(n.li,{children:'If the "cheapest" transaction is 10, and yours is 15, then it likely will be added. However, even in this case, there are scenarios where your transaction might not be added, such as when the lowest-cost transaction currently in the mempool is quite large.'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If the mempool from Chia's mainnet reaches this state, the competition for block space will be strong. In order for your transaction to be included, the minimum fee might be significantly higher than it would be in the other scenarios."}),"\n",(0,t.jsx)(n.h3,{id:"fast-forward-processing",children:"Fast Forward Processing"}),"\n",(0,t.jsx)(n.p,{children:"Starting in Chia 2.5.5, certain transaction types support fast-forward processing, allowing them to be included in blocks more efficiently when specific conditions are met."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Singleton Fast Forward"}),": Singleton transactions now support optimized processing, improving block inclusion rates and handling of high-frequency operations."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Vault Fast Forward"}),": Vault transactions support enhanced processing with optimized validation and faster state transitions, improving overall mempool throughput for vault operations."]}),"\n",(0,t.jsx)(n.h2,{id:"replace-by-fee",children:"Replace by Fee"}),"\n",(0,t.jsx)(n.p,{children:"A transaction can replace another transaction in the mempool if it spends at least the same coins as the original one."}),"\n",(0,t.jsxs)(n.p,{children:["For example, if the original transaction spent coins A and B, then another transaction that spends A, B, and C can replace it. However, a transaction that spends B and C cannot. This prevents denial-of-service (DOS) attacks, as well as censorship of transactions. There is also a minimum fee bump which might depend on mempool software being used. In ",(0,t.jsx)(n.code,{children:"chia-blockchain"}),", this is set to 5 fee-per-cost. This prevents spam replacement transactions."]}),"\n",(0,t.jsx)(n.p,{children:"The full conditions for replace by fee are:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The new spend bundle needs to include at least all the spends in the original one (can include additional spends)"}),"\n",(0,t.jsxs)(n.li,{children:["The new spend bundle needs to pay a higher fee per cost than the original one (and higher than the ",(0,t.jsx)(n.a,{href:"https://docs.chia.net/chia-blockchain/architecture/mempool/#fee-required-for-inclusion",children:"minimum fee required for inclusion"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"The new spend bundle needs to pay at least 10000000 mojos more in fees than the original one"}),"\n",(0,t.jsx)(n.li,{children:"If there were any time-locks associated with the original spend, the new spend bundle has to have the same time-lock"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The replace by fee logic can be found ",(0,t.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/main/chia/full_node/mempool_manager.py#L678",children:"here"}),"in the codebase)"]}),"\n",(0,t.jsx)(n.h2,{id:"block-creation",children:"Block Creation"}),"\n",(0,t.jsx)(n.p,{children:"When the farmer makes a block, they will select the highest fee-per-cost transactions from the mempool until they reach the maximum block size. These spend bundles are combined into one large spend bundle, which is guaranteed to be valid,\nsince all spend bundles in the mempool must spend disjointed coins."}),"\n",(0,t.jsx)(n.p,{children:"Coin spends cannot impact other coin spends, which is a very nice property of UTXO systems, and allows parallelization of validation and block creation. The aggregate\nspend bundle also has one aggregate signature, which is a combination of every signature from every transaction in that block."}),"\n",(0,t.jsx)(n.p,{children:'For performance reasons, the chia-blockchain codebase currently creates only smaller blocks (less than 50% of the maximum size) in order to keep the blockchain smaller and easier to run. This "throttle" is likely to be removed in future versions, after additional optimizations have been performed.'}),"\n",(0,t.jsx)(n.h3,{id:"enhanced-block-creation-chia-255",children:"Enhanced Block Creation (Chia 2.5.5+)"}),"\n",(0,t.jsx)(n.p,{children:"Starting in Chia 2.5.5, a new, more efficient block creation algorithm is available that can be enabled via configuration. This algorithm provides improved performance and better resource utilization during block creation."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Configuration"}),": Set ",(0,t.jsx)(n.code,{children:"full_node:block_creation"})," to ",(0,t.jsx)(n.code,{children:"1"})," in your config file to enable the new algorithm."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Improved block creation performance"}),"\n",(0,t.jsx)(n.li,{children:"Better memory management during block creation"}),"\n",(0,t.jsx)(n.li,{children:"Enhanced handling of high-transaction-volume scenarios"}),"\n",(0,t.jsx)(n.li,{children:"More efficient resource utilization"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Configurable Timeout"}),": Block creation now supports a configurable timeout setting via ",(0,t.jsx)(n.code,{children:"full_node:block_creation_timeout"}),", allowing node operators to fine-tune the process based on their network conditions and requirements."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example Configuration"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"full_node:\n  block_creation: 1 # Enable new algorithm\n  block_creation_timeout: 30 # 30 second timeout\n"})}),"\n",(0,t.jsx)(n.h2,{id:"updating-the-mempool",children:"Updating the Mempool"}),"\n",(0,t.jsxs)(n.p,{children:["After a new block is added to the blockchain, all full nodes must look at the coins that were spent in that new block, and remove them from the mempool. The full node does not need to reapply every transaction again, since Chia coin spends are deterministic and sandboxed (see the ",(0,t.jsx)(n.a,{href:"/chia-blockchain/coin-set-model/intro",children:"Coin Set Intro page"})," for more information). The full node only needs to look at the spent coins in the new block, and if there are any transactions that spend one of those coins, they are removed from the mempool. This means the mempool can be very large, the codebase can be simple, and high performance can be achieved."]}),"\n",(0,t.jsx)(n.h2,{id:"schema-changes-and-migration-chia-255",children:"Schema Changes and Migration (Chia 2.5.5+)"}),"\n",(0,t.jsx)(n.p,{children:"Starting in Chia 2.5.5, the mempool has undergone backwards incompatible schema changes to support the new fast-forward functionality and optimizations."}),"\n",(0,t.jsx)(n.h3,{id:"backwards-incompatible-changes",children:"Backwards Incompatible Changes"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Available in"}),": Chia 2.5.5 and later versions"]}),"\n",(0,t.jsx)(n.p,{children:"The mempool schema has been updated to support:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fast-forward processing"})," for singleton and vault transactions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enhanced transaction deduplication"})," mechanisms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Improved memory management"})," and performance optimizations"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"migration-notes",children:"Migration Notes"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Important"}),": These changes are backwards incompatible. Nodes running versions prior to 2.5.5 may experience issues when connecting to nodes running 2.5.5+."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Required Actions"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Upgrade all nodes"})," to Chia 2.5.5+ simultaneously"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Clear mempool data"})," if upgrading from versions prior to 2.5.5, this will occur automatically after restarting services"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Restart services"})," after upgrade to ensure new schema is applied"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Downgrade Instructions"}),":\nIf you need to downgrade from Chia 2.5.5+ back to an earlier version, you must first fix the database schema incompatibility. See the ",(0,t.jsx)(n.a,{href:"/reference-client/troubleshooting/node-syncing#database-schema-compatibility-issues",children:"Database Schema Compatibility Issues section"})," for the required database fix command and detailed instructions."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Impact"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Existing mempool data may not be compatible with new schema"}),"\n",(0,t.jsx)(n.li,{children:"Transaction processing behavior has changed (see optimizations above)"}),"\n",(0,t.jsx)(n.li,{children:"Performance improvements require full network adoption"}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453(e,n,i){i.d(n,{R:()=>s,x:()=>r});var o=i(6540);const t={},a=o.createContext(t);function s(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);