"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[9866],{1e3:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"chia-blockchain/consensus/chains/harvester-algorithm","title":"Harvester Algorithm","description":"Approximately every 9.375 seconds, the full node sends a new signage point to the farmer, who sends it to each harvester.","source":"@site/docs/chia-blockchain/consensus/chains/harvester-algorithm.md","sourceDirName":"chia-blockchain/consensus/chains","slug":"/chia-blockchain/consensus/chains/harvester-algorithm","permalink":"/zh-Hans/chia-blockchain/consensus/chains/harvester-algorithm","draft":false,"unlisted":false,"editUrl":"https://github.com/Chia-Network/chia-docs/blob/main/docs/chia-blockchain/consensus/chains/harvester-algorithm.md","tags":[],"version":"current","frontMatter":{"title":"Harvester Algorithm","slug":"/chia-blockchain/consensus/chains/harvester-algorithm"},"sidebar":"tutorialSidebar","previous":{"title":"Signage and Infusion Points","permalink":"/zh-Hans/chia-blockchain/consensus/chains/signage-and-infusion-points"},"next":{"title":"Multiple Blocks","permalink":"/zh-Hans/chia-blockchain/consensus/chains/multiple-blocks"}}');var i=t(4848),o=t(8453);const a={title:"Harvester Algorithm",slug:"/chia-blockchain/consensus/chains/harvester-algorithm"},r=void 0,c={},h=[];function l(e){const s={a:"a",code:"code",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:"Approximately every 9.375 seconds, the full node sends a new signage point to the farmer, who sends it to each harvester."}),"\n",(0,i.jsx)(s.p,{children:"The exact protocol message sent for each signage point is the following:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"class PoolDifficulty:\n    difficulty: uint64\n    sub_slot_iters: uint64\n    pool_contract_puzzle_hash: bytes32\n\nclass NewSignagePointHarvester:\n    challenge_hash: bytes32\n    difficulty: uint64\n    sub_slot_iters: uint64\n    signage_point_index: uint8\n    sp_hash: bytes32\n    pool_difficulties: List[PoolDifficulty]\n"})}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"The harvester receives a signage point, and computes the plot filter:"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"plot filter bits = sha256(plot_id + challenge_hash + sp_hash)"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["If the resulting bits start with 9 zeroes, then the plot passes the filter. This does not require disk access, since the plot_ids are stored in memory. 2. For each of the plots passing the filter, a new thread is started, which performs the quality lookups. Recall that this requires around 7-9 random reads into the plot, one for each table. This is where the majority of the disk activity will be. On average, 1 of every 512 plots will perform this step. 3. required_iterations is computed, as explained in the ",(0,i.jsx)(s.a,{href:"/zh-Hans/chia-blockchain/consensus/chains/signage-and-infusion-points",children:"Signage and Infusion Points page"}),". If the farmer is currently farming for a pool, then the pool will use custom values for both ",(0,i.jsx)(s.code,{children:"difficulty"})," and ",(0,i.jsx)(s.code,{children:"sub-slot_iterations"}),". These values make it more likely that a proof will be found. The reason to use these values is to make it easier for the pool to determine the amount of storage a farmer currently has dedicated.\nIf required_iterations is less than the interval_iterations, this proof of space is good (it has won either a pool partial or a block). Most proofs will not pass this step. 5. For winning proofs, the whole proof is fetched on disk (approximately 64 random reads in the plot). 6. The proof is sent back to the farmer."]})]})}function d(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>r});var n=t(6540);const i={},o=n.createContext(i);function a(e){const s=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(o.Provider,{value:s},e.children)}}}]);