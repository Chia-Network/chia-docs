"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[8174],{9774:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>a,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var n=o(4848),r=o(8453);const i={title:"Plot Public Keys",slug:"/plot-public-keys"},s=void 0,l={id:"keys/plot-public-keys",title:"Plot Public Keys",description:"So, what is the plot public key shown in the previous section? The plot public key can technically be any BLS public key. As long as the correct signatures are included in the block, full nodes will allow it. However, BLS allows us to combine many public keys into one, which allows native N-of-N signatures without full nodes noticing that a multi-signature is used. In the current versions of chia-blockchain, we use this to our advantage to increase security. Please note that these schemes are not consensus critical, and therefore some farmers might use different strategies for generating their public keys.",source:"@site/docs/keys/plot-public-keys.md",sourceDirName:"keys",slug:"/plot-public-keys",permalink:"/plot-public-keys",draft:!1,unlisted:!1,editUrl:"https://github.com/Chia-Network/chia-docs/blob/main/docs/keys/plot-public-keys.md",tags:[],version:"current",frontMatter:{title:"Plot Public Keys",slug:"/plot-public-keys"},sidebar:"tutorialSidebar",previous:{title:"Plot IDs",permalink:"/plot-ids"},next:{title:"Chia Protocol",permalink:"/chia-protocol"}},a={},c=[{value:"OG Plots",id:"og-plots",level:2},{value:"Pooled Plots",id:"pooled-plots",level:2},{value:"Plot format",id:"plot-format",level:2}];function h(e){const t={admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["So, what is the plot public key shown in the previous section? The plot public key can technically be any BLS public key. As long as the correct signatures are included in the block, full nodes will allow it. However, BLS allows us to combine many public keys into one, which allows native N-of-N signatures without full nodes noticing that a multi-signature is used. In the current versions of ",(0,n.jsx)(t.code,{children:"chia-blockchain"}),", we use this to our advantage to increase security. Please note that these schemes are not consensus critical, and therefore some farmers might use different strategies for generating their public keys."]}),"\n",(0,n.jsx)(t.p,{children:"The plot public key is usually generated in one of two ways, the first for OG Plots, and the second for pooled plots."}),"\n",(0,n.jsx)(t.h2,{id:"og-plots",children:"OG Plots"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The plot public key is a 2/2 BLS aggregate public key, which is generated by combining the farmer public key with the local public key."}),"\n",(0,n.jsx)(t.li,{children:"The local public key is a random key that is created for each plot, and put into the plot. They are not children of any BLS keys, and therefore are totally independent between plots."}),"\n",(0,n.jsx)(t.li,{children:"The farmer key is a key that the farmer machine stores."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"pooled-plots",children:"Pooled Plots"}),"\n",(0,n.jsx)(t.p,{children:'For plots which are generated for use with the Plot NFT pooling protocol, an additional "taproot" secret key is used, making the aggregate key a 3-of-3. This 3rd key can be derived from public information of the other 2 keys, and it ensures that an attacker cannot create two new keys k1 and k2 such that they both add up to the original aggregate key.'}),"\n",(0,n.jsx)(t.p,{children:"The taproot private key is defined as:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:"taproot_sk = BLSKeyGen(sha256(bytes(local_pk + farmer_pk) + bytes(local_pk) + bytes(farmer_pk)))\n"})}),"\n",(0,n.jsx)(t.p,{children:"Each block requires a signature from the plot key. This means that we need to combine two (or three) signatures:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"from the local secret key (generated by the harvester)"}),"\n",(0,n.jsx)(t.li,{children:"from the farmer secret key (generated by the farmer)"}),"\n",(0,n.jsx)(t.li,{children:"(optional) from the taproot key (generated by the farmer)"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The farmer combines all the signatures to generate the plot signature, which will look like a normal 1-of-1 BLS signature to the rest of the network."}),"\n",(0,n.jsx)(t.p,{children:"Note that signatures from both the local secret key and the farmer secret key are required for the block to be valid. A pool operator cannot derive the farmer secret key if they gain access to the local secret key."}),"\n",(0,n.jsx)(t.h2,{id:"plot-format",children:"Plot format"}),"\n",(0,n.jsx)(t.p,{children:'The plot format depends on whether "farm to public key" or "farm to contract address" is being used. If farming to a contract address, the puzzle hash (address) is directly encoded into the plot. Otherwise, the pool public key is directly encoded into the plot.'}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsx)(t.p,{children:"This is not the exact plot format, there are a few more details that are left out here."})}),"\n",(0,n.jsx)(t.p,{children:"The important thing is that the harvester is only storing their local key in the plot, but no other keys are required from the harvester. This key alone is not enough to do anything, since it must be combined with the farmer's key. Therefore, compromising the harvester does not allow an attacker to redirect rewards."}),"\n",(0,n.jsx)("figure",{children:(0,n.jsx)("img",{src:"/img/keys/plot-format.png",alt:"drawing"})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>l});var n=o(6540);const r={},i=n.createContext(r);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);