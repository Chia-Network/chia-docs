"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[531],{3968:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>n,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"architecture/harvesters","title":"Harvesters","description":"Harvesters are individual machines controlled by a farmer. In a large farming operation, a farmer may be connected to many harvesters.","source":"@site/docs/architecture/harvesters.md","sourceDirName":"architecture","slug":"/harvester-architecture","permalink":"/harvester-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/Chia-Network/chia-docs/blob/main/docs/architecture/harvesters.md","tags":[],"version":"current","frontMatter":{"title":"Harvesters","slug":"/harvester-architecture"},"sidebar":"tutorialSidebar","previous":{"title":"Farmers","permalink":"/farmer-architecture"},"next":{"title":"Timelords","permalink":"/timelord-architecture"}}');var s=r(4848),i=r(8453);const a={title:"Harvesters",slug:"/harvester-architecture"},n=void 0,l={},c=[];function h(e){const t={a:"a",admonition:"admonition",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Harvesters are individual machines controlled by a farmer. In a large farming operation, a farmer may be connected to many harvesters."}),"\n",(0,s.jsx)(t.p,{children:"Harvesters control the actual plot files by retrieving qualities or proofs from disk. The minimum plot size (and by far the most common) is k32, which corresponds to around 100 GiB. With each increment of a k-value, the plot size roughly doubles, so a k33 plot is around 200 GiB, k34 is around 400 GiB, etc."}),"\n",(0,s.jsx)(t.p,{children:"The difficulty level automatically adjusts every 4608 blocks to target one proof of space -- across the entire network -- for every two signage points. This is the targeted average value -- there can also be zero or multiple proofs per signage point. This leads to a difficulty adjustment approximately every 24 hours."}),"\n",(0,s.jsx)(t.p,{children:"Given a plot, the harvester must perform two tasks to find a valid proof:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Fetch the initial quality -- this requires around seven random disk seeks, or 70 milliseconds on a slow HDD."}),"\n",(0,s.jsx)(t.li,{children:"(Only performed if the initial quality is sufficiently high) Fetch the full proof -- this requires around 64 disk seeks, or 640 milliseconds on a slow HDD."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"For most challenges, the quality (step 1) will be very low, so fetching the entire proof (step 2) will not be necessary. A node has 28 seconds to return a proof, so disk I/O will not be a limiting factor, even when proofs are stored on slow HDDs."}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"Tape drives are too slow for farming. The protocol was designed to support hard disks, but nothing slower. It is possible to use tape for long-term plot storage, only transferring the plots to disks for occasional farming, but this is likely a very rare use case."})}),"\n",(0,s.jsx)(t.p,{children:"Finally, harvesters also maintain a private key for each plot. The blocks are signed with these keys, which is an important concept in Chia. It means that even when a farmer is a member of a pool, the farmer still controls the contents of a block. This is quite different from other blockchains' pooling protocols, where the pool operators are the ones signing the blocks."}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["The harvester algorithm is discussed in greater detail in the ",(0,s.jsx)(t.a,{href:"/harvester-algorithm",children:"Harvester Algorithm page"}),"."]})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>n});var o=r(6540);const s={},i=o.createContext(s);function a(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function n(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);