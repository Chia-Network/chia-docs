"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[2427],{5872:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"architecture/mempool","title":"Mempool","description":"The mempool (or memory pool) is a collection of transactions stored by full nodes, usually in memory, before they are confirmed on the blockchain. The mempool is not dictated by the consensus rules; a farmer can change how their mempool functions and customize the rules without permission from other full nodes.","source":"@site/docs/architecture/mempool.md","sourceDirName":"architecture","slug":"/mempool","permalink":"/mempool","draft":false,"unlisted":false,"editUrl":"https://github.com/Chia-Network/chia-docs/blob/main/docs/architecture/mempool.md","tags":[],"version":"current","frontMatter":{"title":"Mempool","slug":"/mempool"},"sidebar":"tutorialSidebar","previous":{"title":"Wallets","permalink":"/wallet-architecture"},"next":{"title":"Consensus Introduction","permalink":"/consensus-intro"}}');var i=o(4848),s=o(8453);const a={title:"Mempool",slug:"/mempool"},l=void 0,r={},c=[{value:"Validation",id:"validation",level:2},{value:"Fee Required for Inclusion",id:"fee-required-for-inclusion",level:2},{value:"Scenario 1: Mempool Not Busy",id:"scenario-1-mempool-not-busy",level:3},{value:"Scenario 2: Mempool Busy But Not Full",id:"scenario-2-mempool-busy-but-not-full",level:3},{value:"Scenario 3: Mempool Full",id:"scenario-3-mempool-full",level:3},{value:"Scenario 4: Mempool Full of Transactions with Fees",id:"scenario-4-mempool-full-of-transactions-with-fees",level:3},{value:"Replace by Fee",id:"replace-by-fee",level:2},{value:"Block Creation",id:"block-creation",level:2},{value:"Updating the Mempool",id:"updating-the-mempool",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"The mempool (or memory pool) is a collection of transactions stored by full nodes, usually in memory, before they are confirmed on the blockchain. The mempool is not dictated by the consensus rules; a farmer can change how their mempool functions and customize the rules without permission from other full nodes."}),"\n",(0,i.jsx)(n.p,{children:"The mempool is a required facet of Chia due to the decentralized nature of the blockchain. Transaction blocks occur approximately every 52 seconds, and it's impossible to predict who will win a block. Therefore, all transactions must be broadcast to the whole network and stored locally until they are confirmed. Additionally, it is normal to have more pending transactions than can fit in a single block, so the mempool also acts as a queue for inclusion into the blockchain."}),"\n",(0,i.jsxs)(n.p,{children:["For more information about the mempool, see our ",(0,i.jsx)(n.a,{href:"https://www.chia.net/2024/01/12/getting-to-know-the-mempool-and-transaction-fees/",children:"blog post"})," on this subject."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:'How many transactions can fit into a block? Due to the varying size of transactions, and the different definitions of what even counts as a "transaction," there is not an exact number. But just for a bit of rough guidance, approximately 1000 transactions with two inputs and two outputs, or 2000 transactions with one input and one output can fit into a single block.'})}),"\n",(0,i.jsx)(n.p,{children:"When a user makes a transaction, it gets sent to a full node, which then verifies it, adds it to the mempool, and broadcasts it to all of its peers. Therefore, transactions get propagated to the whole network in a very short period of time."}),"\n",(0,i.jsx)(n.h2,{id:"validation",children:"Validation"}),"\n",(0,i.jsx)(n.p,{children:"Only valid transactions are allowed to enter the mempool. The process of validating transactions is similar to the process of validating blocks. This includes running CLVM, checking conditions, validating signatures, and checking that the coins to be spent are currently unspent and valid."}),"\n",(0,i.jsx)(n.p,{children:"The transaction is also checked against other transactions in the mempool, to ensure there are no conflicts."}),"\n",(0,i.jsx)(n.h2,{id:"fee-required-for-inclusion",children:"Fee Required for Inclusion"}),"\n",(0,i.jsx)(n.p,{children:"When you submit a transaction, one of several possible scenarios will play out, depending on how full the mempool is, how large of a fee was included, the CLVM cost of the transaction, and other factors. Keep in mind that each farmer has its own copy of the mempool, with its own set of rules. The default mempool behavior discussed in this section will apply to most, but not all, nodes. It is up to each individual farmer to decide which transactions to include upon creating a block."}),"\n",(0,i.jsxs)(n.p,{children:["To view the current status of the mempool, see the dashboard for ",(0,i.jsx)(n.a,{href:"https://dashboard.chia.net/d/46EAA05E/mempool-transactions-and-fees?orgId=1&var-network=mainnet",children:"mainnet"})," and ",(0,i.jsx)(n.a,{href:"https://dashboard.chia.net/d/46EAA05E/mempool-transactions-and-fees?orgId=1&var-network=testnet11",children:"testnet11"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"By default, the total size of the mempool is 20 blocks. This true for both mainnet and testnet11."}),"\n",(0,i.jsx)(n.li,{children:"Prior to version 2.2, the block size was artificially capped at 50% of its capacity."}),"\n",(0,i.jsx)(n.li,{children:"Starting in version 2.2, the block size cap was increased to 60%."}),"\n",(0,i.jsx)(n.li,{children:"This limitation will be increased gradually, until it reaches 100%, or 11 billion cost -- the limit enforced by the consensus rules."}),"\n",(0,i.jsxs)(n.li,{children:["The size (in CLVM cost) of the mempool is ",(0,i.jsx)(n.code,{children:"mempool blocks * max cost per block * block size limit"}),".","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["In version 2.2, this amounts to ",(0,i.jsx)(n.code,{children:"20 * 11 billion * 0.6"}),", which equals 132 billion."]}),"\n",(0,i.jsxs)(n.li,{children:["When the block limiter is lifted, the total size will be ",(0,i.jsx)(n.code,{children:"20 * 11 billion"}),", or 220 billion."]}),"\n"]}),"\n"]}),"\n"]})}),"\n",(0,i.jsx)(n.h3,{id:"scenario-1-mempool-not-busy",children:"Scenario 1: Mempool Not Busy"}),"\n",(0,i.jsx)(n.p,{children:"If the transaction you just submitted -- plus the entire contents of the mempool -- can fit into one block, then your transaction will be added to the next block. This is true even if you don't include a transaction fee."}),"\n",(0,i.jsxs)(n.p,{children:["The reason for this is straightforward -- the farmer has nothing to gain by excluding certain transactions, so it will include everything. Note that some proprietary software takes the opposite approach: the farmer will ",(0,i.jsx)(n.em,{children:"only"})," include transactions that pay a fee, regardless of mempool size."]}),"\n",(0,i.jsx)(n.p,{children:"The mempool for Chia's mainnet is often in this state. This does not mean that no transactions are being submitted. It simply means that the network's speed of around 20 transactions per second is sufficient to keep up with demand."}),"\n",(0,i.jsx)(n.h3,{id:"scenario-2-mempool-busy-but-not-full",children:"Scenario 2: Mempool Busy But Not Full"}),"\n",(0,i.jsxs)(n.p,{children:["If the mempool's contents will occupy more than one block, but the mempool is not full, then it is considered ",(0,i.jsx)(n.em,{children:"busy"}),". In this case:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Transactions that don't include fees will be added to the mempool, but they won't make it into the next block. Instead, they will have to \"wait in line\" for higher-priority transactions to be cleared. They likely will eventually be included in a block, but this is not guaranteed."}),"\n",(0,i.jsx)(n.li,{children:"Transactions with fees will be added to the mempool and prioritized according to the size of their fee-per-cost. For example, a transaction with a 1-mojo fee will enter the queue ahead of zero-fee transactions."}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{title:"Testnet11 info",type:"info",children:(0,i.jsx)(n.p,{children:'Testnet11 is constantly being "dusted" (thousands of small transactions are being included) in order to simulate a busy network, which can be useful for testing. The dust transactions do not include any fees, so in order for your transaction to be prioritized ahead of the dust, you simply have to include a 1-mojo fee. In this case, your transaction will likely be included in the next transaction block. However, if you don\'t include a fee, it will likely need to wait ~40-60 minutes before being included.'})}),"\n",(0,i.jsx)(n.h3,{id:"scenario-3-mempool-full",children:"Scenario 3: Mempool Full"}),"\n",(0,i.jsx)(n.p,{children:"If the mempool is completely full, then in order for your transaction to be added, it will need to kick out one or more transactions. In this scenario:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Transactions with no fee will not be added to the mempool."}),"\n",(0,i.jsx)(n.li,{children:"Transactions with a fee of less than five mojos per cost (~100 million mojos for 2-input, 2-output transactions) will be treated as zero-fee transactions, i.e. they will not be added to the mempool."}),"\n",(0,i.jsxs)(n.li,{children:["Transactions with a fee of at least five mojos per cost will be added to the mempool, prioritized by fee-per-cost, ",(0,i.jsx)(n.em,{children:"if"})," they are not the lowest priority transactions (see Scenario 4 in this case)."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This scenario often occurs on testnet11. When the mempool is completely full, the dusters stop submitting transactions until some of the dust has been cleared. This scenario might occasionally happen on mainnet as well, in which case a minimum fee would be required."}),"\n",(0,i.jsxs)(n.p,{children:["If you see ",(0,i.jsx)(n.code,{children:"INVALID_FEE_TOO_CLOSE_TO_ZERO"})," in your log file, the mempool was likely full when you submitted your transaction, and you did not include a sufficient fee to kick out an existing transaction. Try resubmitting your transaction with a higher fee."]}),"\n",(0,i.jsx)(n.h3,{id:"scenario-4-mempool-full-of-transactions-with-fees",children:"Scenario 4: Mempool Full of Transactions with Fees"}),"\n",(0,i.jsx)(n.p,{children:"This is the final scenario, where every transaction in the mempool has a fee of at least five mojos per cost. In order for your transaction to be added, it will need to kick out one or more transactions. In this scenario:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Transactions with no fee will not be added to the mempool."}),"\n",(0,i.jsx)(n.li,{children:"Transactions with a fee of less than five mojos per cost (~100 million mojos for 2-input, 2-output transactions) will be treated as zero-fee transactions, i.e. they will not be added to the mempool."}),"\n",(0,i.jsxs)(n.li,{children:["Transactions with a fee of at least five mojos per cost ",(0,i.jsx)(n.em,{children:"might"})," be added to mempool. For this to happen, they will need to kick out one or more transactions with a lower fee-per-cost ratio. For example:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'If the "cheapest" transaction currently in the mempool has a fee per cost of 10, and your transaction\'s fee per cost is 9, then your transaction will not be added to the mempool.'}),"\n",(0,i.jsx)(n.li,{children:'If the "cheapest" transaction is 10, and yours is 15, then it likely will be added. However, even in this case, there are scenarios where your transaction might not be added, such as when the lowest-cost transaction currently in the mempool is quite large.'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If the mempool from Chia's mainnet reaches this state, the competition for block space will be strong. In order for your transaction to be included, the minimum fee might be significantly higher than it would be in the other scenarios."}),"\n",(0,i.jsx)(n.h2,{id:"replace-by-fee",children:"Replace by Fee"}),"\n",(0,i.jsx)(n.p,{children:"A transaction can replace another transaction in the mempool if it spends at least the same coins as the original one."}),"\n",(0,i.jsxs)(n.p,{children:["For example, if the original transaction spent coins A and B, then another transaction that spends A, B, and C can replace it. However, a transaction that spends B and C cannot. This prevents denial-of-service (DOS) attacks, as well as censorship of transactions. There is also a minimum fee bump which might depend on mempool software being used. In ",(0,i.jsx)(n.code,{children:"chia-blockchain"}),", this is set to 5 fee-per-cost. This prevents spam replacement transactions."]}),"\n",(0,i.jsx)(n.p,{children:"The full conditions for replace by fee are:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The new spend bundle needs to include at least all the spends in the original one (can include additional spends)"}),"\n",(0,i.jsxs)(n.li,{children:["The new spend bundle needs to pay a higher fee per cost than the original one (and higher than the ",(0,i.jsx)(n.a,{href:"https://docs.chia.net/mempool/#fee-required-for-inclusion",children:"minimum fee required for inclusion"}),")"]}),"\n",(0,i.jsx)(n.li,{children:"The new spend bundle needs to pay at least 10000000 mojos more in fees than the original one"}),"\n",(0,i.jsx)(n.li,{children:"If there were any time-locks associated with the original spend, the new spend bundle has to have the same time-lock"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The replace by fee logic can be found ",(0,i.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/main/chia/full_node/mempool_manager.py#L678",children:"here"}),"in the codebase)"]}),"\n",(0,i.jsx)(n.h2,{id:"block-creation",children:"Block Creation"}),"\n",(0,i.jsx)(n.p,{children:"When the farmer makes a block, they will select the highest fee-per-cost transactions from the mempool until they reach the maximum block size. These spend bundles are combined into one large spend bundle, which is guaranteed to be valid,\nsince all spend bundles in the mempool must spend disjointed coins."}),"\n",(0,i.jsx)(n.p,{children:"Coin spends cannot impact other coin spends, which is a very nice property of UTXO systems, and allows parallelization of validation and block creation. The aggregate\nspend bundle also has one aggregate signature, which is a combination of every signature from every transaction in that block."}),"\n",(0,i.jsx)(n.p,{children:'For performance reasons, the chia-blockchain codebase currently creates only smaller blocks (less than 50% of the maximum size) in order to keep the blockchain smaller and easier to run. This "throttle" is likely to be removed in future versions, after additional optimizations have been performed.'}),"\n",(0,i.jsx)(n.h2,{id:"updating-the-mempool",children:"Updating the Mempool"}),"\n",(0,i.jsxs)(n.p,{children:["After a new block is added to the blockchain, all full nodes must look at the coins that were spent in that new block, and remove them from the mempool. The full node does not need to reapply every transaction again, since Chia coin spends are deterministic and sandboxed (see the ",(0,i.jsx)(n.a,{href:"/coin-set-intro",children:"Coin Set Intro page"})," for more information). The full node only needs to look at the spent coins in the new block, and if there are any transactions that spend one of those coins, they are removed from the mempool. This means the mempool can be very large, the codebase can be simple, and high performance can be achieved."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>l});var t=o(6540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);