"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[5525],{9253:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=t(5893),n=t(1151);t(4866),t(5162);const o={sidebar_label:"Compressed Plots",title:"Compressed Plot Farming",slug:"/farming-compressed-plots"},i=void 0,l={id:"farming/farming-compressed-plots",title:"Compressed Plot Farming",description:"As detailed in the plotting section, compressed plots are supported for both plotting and harvesting as of Chia version 2.0. Before you can harvest compressed plots, you need to inform your harvesters of the fact that they exist.",source:"@site/docs/farming/farming-compressed-plots.md",sourceDirName:"farming",slug:"/farming-compressed-plots",permalink:"/farming-compressed-plots",draft:!1,unlisted:!1,editUrl:"https://github.com/Chia-Network/chia-docs/blob/main/docs/farming/farming-compressed-plots.md",tags:[],version:"current",frontMatter:{sidebar_label:"Compressed Plots",title:"Compressed Plot Farming",slug:"/farming-compressed-plots"},sidebar:"tutorialSidebar",previous:{title:"Farming Basics",permalink:"/farming-basics"},next:{title:"Farming on Many Machines",permalink:"/farming-on-many-machines"}},a={},c=[{value:"Enable compressed plot support",id:"enable-compressed-plot-support",level:2},{value:"GUI",id:"gui",level:3},{value:"CLI",id:"cli",level:3}];function d(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,n.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.p,{children:["As detailed in the ",(0,r.jsx)(s.a,{href:"/plotting-basics",children:"plotting"})," section, compressed plots are supported for both plotting and harvesting as of Chia version 2.0. Before you can harvest compressed plots, you need to inform your harvesters of the fact that they exist."]}),"\n",(0,r.jsxs)(s.admonition,{type:"info",children:[(0,r.jsx)(s.p,{children:"As of Chia version 2.0, decompression must be performed at the harvester level. You therefore will need to apply the settings listed on this page to each of your harvesters individually. This also means that each individual harvester will need to be capable of decompressing the plots that have been installed locally."}),(0,r.jsx)(s.p,{children:"In the future, we plan to enable decompression at the farmer level. This means that only one computer on your network will need to be equipped with a fast CPU or GPU for decompressing plots."})]}),"\n",(0,r.jsx)(s.h2,{id:"enable-compressed-plot-support",children:"Enable compressed plot support"}),"\n",(0,r.jsx)(s.h3,{id:"gui",children:"GUI"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["Navigate to the ",(0,r.jsx)(s.code,{children:"Settings"})," panel in the lower-left corner of the GUI."]}),"\n",(0,r.jsxs)(s.li,{children:["Click the ",(0,r.jsx)(s.code,{children:"HARVESTER"})," tab at the top of the panel. The following screen will appear:"]}),"\n"]}),"\n",(0,r.jsx)("div",{style:{textAlign:"left"},children:(0,r.jsx)("img",{src:"/img/compressed-farming/01.png",alt:"Enable compressed farming"})}),"\n",(0,r.jsxs)(s.ol,{start:"3",children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["Slide the ",(0,r.jsx)(s.code,{children:"Enable compressed plot support"})," slider to the right, as shown in the above image."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["For ",(0,r.jsx)(s.code,{children:"Parallel Decompressor Count"}),", the default value of ",(0,r.jsx)(s.code,{children:"1"})," will be fine for most users. Here are some details:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["This number ",(0,r.jsx)(s.em,{children:"only"})," affects the amount of memory used for decompression."]}),"\n",(0,r.jsxs)(s.li,{children:["The amount memory required will vary according to the level of compression. For example, if ",(0,r.jsx)(s.code,{children:"Parallel Decompressor Count"})," is set to ",(0,r.jsx)(s.code,{children:"1"}),", around 600-700 MB of memory will be consumed while decompressing a single C7 plot."]}),"\n",(0,r.jsxs)(s.li,{children:["The amount of memory required will scale linearly, so setting it to ",(0,r.jsx)(s.code,{children:"2"})," will double the required memory."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["If your harvester has sufficient memory, as well as a high CPU core count, you can increase this number. For example, ",(0,r.jsx)(s.code,{children:"2"})," might be optimal for a 16-core CPU, or ",(0,r.jsx)(s.code,{children:"4"})," for dual 32-core CPUs."]}),"\n",(0,r.jsxs)(s.p,{children:["However, the generation and speed of your CPU will also have a large impact on the optimal setting. If you do increase ",(0,r.jsx)(s.code,{children:"Parallel Decompressor Count"}),", be sure to monitor your harvester's performance as there is no one-size-fits-all solution."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["The default value for ",(0,r.jsx)(s.code,{children:"Decompressor Thread Count"})," is ",(0,r.jsx)(s.code,{children:"0"}),". This is the number of threads that will participate in decompressing plots. This number, multiplied by ",(0,r.jsx)(s.code,{children:"Parallel Decompressor Count"}),", needs to less than or equal to the total number of harvester cores."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"For example, if your harvester has one CPU with eight cores, you might use the following settings:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"Parallel Decompressor Count"}),": ",(0,r.jsx)(s.code,{children:"1"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"Decompressor Thread Count"}),": ",(0,r.jsx)(s.code,{children:"6"})]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["This would instruct the harvester process to use six of the eight cores for decompressing plots, and to use the remaining cores to run the OS, etc.\n5. If you want to use a GPU for harvesting, slide the ",(0,r.jsx)(s.code,{children:"Enable GPU Harvesting"})," slider to the right, as shown in the above image. Note that in order to use this setting, your harvester must have an NVIDIA CUDA-class GPU. For harvesting C7 plots, 600-700 MB of DRAM is required.\n6. If your harvester has multiple GPUs, you can use ",(0,r.jsx)(s.code,{children:"GPU Device Index"})," to choose which one to use. If your harvester only has one GPU, then leave this set to ",(0,r.jsx)(s.code,{children:"0"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["After all of these settings have been properly set, click the red ",(0,r.jsx)(s.code,{children:"RESTART LOCAL HARVESTER TO APPLY CHANGES"})," button. After your harvester restarts, it will use the updated settings."]}),"\n",(0,r.jsx)(s.h3,{id:"cli",children:"CLI"}),"\n",(0,r.jsxs)(s.p,{children:["All of the new harvester settings live inside ",(0,r.jsx)(s.code,{children:"~/.chia/mainnet/config/config.yaml"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["If you have never installed Chia on this harvester, ",(0,r.jsx)(s.code,{children:"config.yaml"})," won't exist. In this case, run the following command to generate a new copy:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"chia init\n"})}),"\n",(0,r.jsxs)(s.p,{children:["If you have previously installed Chia on this computer, then ",(0,r.jsx)(s.code,{children:"config.yaml"})," likely already exists. In this case, you will need to add several new settings. However,"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["If you run ",(0,r.jsx)(s.code,{children:"chia init"})," when the config file already exists, Chia won't make any modifications."]}),"\n",(0,r.jsxs)(s.li,{children:["If you delete ",(0,r.jsx)(s.code,{children:"config.yaml"})," and run ",(0,r.jsx)(s.code,{children:"chia init"}),", the new settings will be added, but you will lose any custom changes you previously made."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["In the case where ",(0,r.jsx)(s.code,{children:"config.yaml"})," already exists, you therefore are recommended to do the following:"]}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["Edit ",(0,r.jsx)(s.code,{children:"config.yaml"})]}),"\n",(0,r.jsxs)(s.li,{children:["Search for ",(0,r.jsx)(s.code,{children:"harvester:"})]}),"\n",(0,r.jsx)(s.li,{children:"From inside this section, add the following parameters, which include the default settings:"}),"\n"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"parallel_decompressor_count: 0\ndecompressor_thread_count: 0\nuse_gpu_harvesting: false\nenforce_gpu_index: false\ngpu_index: 0\ndecompressor_timeout: 20\ndisable_cpu_affinity: false\nmax_compression_level_allowed: 7\n"})}),"\n",(0,r.jsxs)(s.p,{children:["At this point, regardless of whether you are upgrading or running a new build of Chia on this harvester, your copy of ",(0,r.jsx)(s.code,{children:"config.yaml"})," contains all of the latest settings. Their definitions and recommended values are as follows:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"parallel_decompressor_count"}),": The number of CPUs to be used for decompressing plots. If this is set to ",(0,r.jsx)(s.code,{children:"0"}),", then harvesting of compressed plots will be disabled. For GPU harvesting, set this value to ",(0,r.jsx)(s.code,{children:"1"}),". For CPU harvesting, set it to the number of CPUs you want to use for decompression (typically ",(0,r.jsx)(s.code,{children:"1"}),")."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"decompressor_thread_count"}),": The number of CPU threads that will participate in decompressing plots. This number multiplied by ",(0,r.jsx)(s.code,{children:"Parallel Decompressor Count"})," needs to less than or equal to the total number of CPU cores."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"use_gpu_harvesting"}),": Set to ",(0,r.jsx)(s.code,{children:"true"})," to enable harvesting with a GPU. Note that in order to use this setting, your harvester must have an NVIDIA GPU with CUDA capability 5.2 and up, with at least 8GB of vRAM."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"gpu_index"}),": If your harvester has multiple GPUs, use this setting to choose which one to use. If your harvester only has one GPU, then leave this set to ",(0,r.jsx)(s.code,{children:"0"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"enforce_gpu_index"}),": Set to ",(0,r.jsx)(s.code,{children:"true"})," if your harvester has more than one GPU and you want to use one other than the default of ",(0,r.jsx)(s.code,{children:"0"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"decompressor_timeout"}),": The number of seconds for your decompressor to time out. The default value of ",(0,r.jsx)(s.code,{children:"20"})," is typically fine."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"disable_cpu_affinity"}),": This should typically be ",(0,r.jsx)(s.code,{children:"false"}),". When it is ",(0,r.jsx)(s.code,{children:"false"}),", when using multiple CPU decompressors, each with multiple threads, the threads for each decompressor will be assigned to different physical CPUs. This prevents them for competing over compute time. If it is set to ",(0,r.jsx)(s.code,{children:"true"}),", the threads for each decompressor will be assigned to the same CPU."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"max_compression_level_allowed"}),": The highest level of compression your harvester will support. In Chia version 2.0, the maximum level is ",(0,r.jsx)(s.code,{children:"7"}),". This will likely be increased in the future, but for now, you cannot increase it beyond the default. You can, however, set it to a lower number if desired."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["After you have finished making these updates, save ",(0,r.jsx)(s.code,{children:"config.yaml"})," and restart your harvester by running the following command:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"chia start harvester -r\n"})}),"\n",(0,r.jsx)(s.p,{children:"Your new settings will be applied."})]})}function h(e={}){const{wrapper:s}={...(0,n.a)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},5162:(e,s,t)=>{t.d(s,{Z:()=>i});t(7294);var r=t(512);const n={tabItem:"tabItem_Ymn6"};var o=t(5893);function i(e){let{children:s,hidden:t,className:i}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.Z)(n.tabItem,i),hidden:t,children:s})}},4866:(e,s,t)=>{t.d(s,{Z:()=>w});var r=t(7294),n=t(512),o=t(2466),i=t(6550),l=t(469),a=t(1980),c=t(7392),d=t(12);function h(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:s}=e;return!!s&&"object"==typeof s&&"value"in s}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:s,children:t}=e;return(0,r.useMemo)((()=>{const e=s??function(e){return h(e).map((e=>{let{props:{value:s,label:t,attributes:r,default:n}}=e;return{value:s,label:t,attributes:r,default:n}}))}(t);return function(e){const s=(0,c.l)(e,((e,s)=>e.value===s.value));if(s.length>0)throw new Error(`Docusaurus error: Duplicate values "${s.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[s,t])}function p(e){let{value:s,tabValues:t}=e;return t.some((e=>e.value===s))}function m(e){let{queryString:s=!1,groupId:t}=e;const n=(0,i.k6)(),o=function(e){let{queryString:s=!1,groupId:t}=e;if("string"==typeof s)return s;if(!1===s)return null;if(!0===s&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:s,groupId:t});return[(0,a._X)(o),(0,r.useCallback)((e=>{if(!o)return;const s=new URLSearchParams(n.location.search);s.set(o,e),n.replace({...n.location,search:s.toString()})}),[o,n])]}function f(e){const{defaultValue:s,queryString:t=!1,groupId:n}=e,o=u(e),[i,a]=(0,r.useState)((()=>function(e){let{defaultValue:s,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(s){if(!p({value:s,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${s}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return s}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:s,tabValues:o}))),[c,h]=m({queryString:t,groupId:n}),[f,g]=function(e){let{groupId:s}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(s),[n,o]=(0,d.Nk)(t);return[n,(0,r.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:n}),x=(()=>{const e=c??f;return p({value:e,tabValues:o})?e:null})();(0,l.Z)((()=>{x&&a(x)}),[x]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);a(e),h(e),g(e)}),[h,g,o]),tabValues:o}}var g=t(2389);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=t(5893);function b(e){let{className:s,block:t,selectedValue:r,selectValue:i,tabValues:l}=e;const a=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.o5)(),d=e=>{const s=e.currentTarget,t=a.indexOf(s),n=l[t].value;n!==r&&(c(s),i(n))},h=e=>{let s=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const t=a.indexOf(e.currentTarget)+1;s=a[t]??a[0];break}case"ArrowLeft":{const t=a.indexOf(e.currentTarget)-1;s=a[t]??a[a.length-1];break}}s?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,n.Z)("tabs",{"tabs--block":t},s),children:l.map((e=>{let{value:s,label:t,attributes:o}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:r===s?0:-1,"aria-selected":r===s,ref:e=>a.push(e),onKeyDown:h,onClick:d,...o,className:(0,n.Z)("tabs__item",x.tabItem,o?.className,{"tabs__item--active":r===s}),children:t??s},s)}))})}function j(e){let{lazy:s,children:t,selectedValue:n}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(s){const e=o.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:o.map(((e,s)=>(0,r.cloneElement)(e,{key:s,hidden:e.props.value!==n})))})}function y(e){const s=f(e);return(0,v.jsxs)("div",{className:(0,n.Z)("tabs-container",x.tabList),children:[(0,v.jsx)(b,{...e,...s}),(0,v.jsx)(j,{...e,...s})]})}function w(e){const s=(0,g.Z)();return(0,v.jsx)(y,{...e,children:h(e.children)},String(s))}},1151:(e,s,t)=>{t.d(s,{Z:()=>l,a:()=>i});var r=t(7294);const n={},o=r.createContext(n);function i(e){const s=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(o.Provider,{value:s},e.children)}}}]);