"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[3900],{6609:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>h});var n=i(4848),a=i(8453);i(1470),i(9365);const r={sidebar_label:"Technical Details",title:"Technical Details",slug:"/new-proof-details"},o=void 0,s={id:"new-proof-format/new-proof-technical-details",title:"Technical Details",description:"New Matching Algorithm",source:"@site/docs/new-proof-format/new-proof-technical-details.md",sourceDirName:"new-proof-format",slug:"/new-proof-details",permalink:"/new-proof-details",draft:!1,unlisted:!1,editUrl:"https://github.com/Chia-Network/chia-docs/blob/main/docs/new-proof-format/new-proof-technical-details.md",tags:[],version:"current",frontMatter:{sidebar_label:"Technical Details",title:"Technical Details",slug:"/new-proof-details"},sidebar:"tutorialSidebar",previous:{title:"Technical Overview",permalink:"/new-proof-technical-overview"},next:{title:"Proof of Time",permalink:"/proof-of-time"}},l={},h=[{value:"New Matching Algorithm",id:"new-matching-algorithm",level:2},{value:"Matching Bits",id:"matching-bits",level:3},{value:"T1 Matching",id:"t1-matching",level:3},{value:"Matching Difficulty",id:"matching-difficulty",level:3},{value:"New Plot Filters",id:"new-plot-filters",level:2},{value:"Plot Id Filter",id:"plot-id-filter",level:3},{value:"EncryptedX\u2019s Scan Filter",id:"encryptedxs-scan-filter",level:3},{value:"The Challenge",id:"the-challenge",level:4},{value:"Random x-quadruple quality filter",id:"random-x-quadruple-quality-filter",level:3},{value:"Benefits",id:"benefits",level:3},{value:"Benes Compression",id:"benes-compression",level:2},{value:"Further Compression by Additional Bit Dropping",id:"further-compression-by-additional-bit-dropping",level:2},{value:"Impact to Honest Farmers",id:"impact-to-honest-farmers",level:2},{value:"Impact to Rental Attacks",id:"impact-to-rental-attacks",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"new-matching-algorithm",children:"New Matching Algorithm"}),"\n",(0,n.jsx)(t.p,{children:"The matching algorithm for all tables has changed, and now forms the basis of security. It is a memory hard algorithm which can be tuned to take more or less time by adjusting the number of match indexes to test for whether two entries match."}),"\n",(0,n.jsx)(t.p,{children:"The benefit of this algorithm is that we can set the difficulty very high so that plotting will take longer and compression attacks will be more expensive, yet it incurs negligible cost when validating a proof. Since validation is \u201cfree\u201d, we can tune this to be as difficult as we need, without adding extra compute expense to the network."}),"\n",(0,n.jsx)(t.h3,{id:"matching-bits",children:"Matching Bits"}),"\n",(0,n.jsx)(t.p,{children:"The matching algorithm takes an additional index number which is used to show that a match works. The left value and the index results in a bucket. This must match a bucket which the right value hashes to, and the matching combination of them have to pass an additional filter. Index bits will be included in proofs to make verification fast. To keep required memory down, entries are sorted into sections. All of the buckets to which a left value hashes will land in the same section."}),"\n",(0,n.jsx)(t.h3,{id:"t1-matching",children:"T1 Matching"}),"\n",(0,n.jsx)(t.p,{children:"For the first table of matches, we match a k-bit value that comprises section_bits and random_bits. Match_index_bits is an additional variable to define which match_index creates a match."}),"\n",(0,n.jsx)(t.p,{children:"For the first set of pairs, x1 and x2 match iff:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The upper section_bits of x1 are equal to the upper section bits of x2."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["There exists a match_index in the range ",(0,n.jsx)(t.code,{children:"[0..<2^match_index_bits]"})," where the random_bits produced from hash(x1 + plot_id + match_index) are equal to the random_bits produced from x2 with hash(x2 + plot_id)."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"A new_meta is created by hashing x1 and x2."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"A hash of new_meta must pass a filter for it to be a match."}),"\n",(0,n.jsx)("div",{style:{textAlign:"center"},children:(0,n.jsx)("img",{src:"/img/new_format/plot_chart.png",alt:"Flow chart"})}),"\n",(0,n.jsx)("br",{}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"matching-difficulty",children:"Matching Difficulty"}),"\n",(0,n.jsx)(t.p,{children:"The time to find a match is heavily influenced by match_index_bits, as the higher the range of match_indexes the more the number of lookups to test for a match."}),"\n",(0,n.jsx)(t.p,{children:"Since most bit dropping attacks are limited by the difficulty of matching in the earlier tables, the number of match index_bits will be tuned much higher for the first and second tables, and set lower for subsequent tables."}),"\n",(0,n.jsx)(t.h2,{id:"new-plot-filters",children:"New Plot Filters"}),"\n",(0,n.jsx)(t.p,{children:"The new proof of space comprises 3 plot filters:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Plot id filter"}),"\n",(0,n.jsx)(t.li,{children:"EncryptedX\u2019s scan filter"}),"\n",(0,n.jsx)(t.li,{children:"Random x-quadruple quality filter"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"plot-id-filter",children:"Plot Id Filter"}),"\n",(0,n.jsx)(t.p,{children:"The plot id filter is the same as the original proof of space \u2013 the challenge and plot id create a hash that validates the plot for that challenge if it passes the filter. For the new proof of space we will be able to reduce this filter significantly compared to the original. Once set, it is expected to stay fixed over time."}),"\n",(0,n.jsx)(t.h3,{id:"encryptedxs-scan-filter",children:"EncryptedX\u2019s Scan Filter"}),"\n",(0,n.jsx)(t.p,{children:"A few definitions:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"x1 and x2 are pairs matched in the first table, and are the left side match in the next table."}),"\n",(0,n.jsx)(t.li,{children:"x3 and x4 are pairs matched in the first table, that then form the right-side match with x1 and x2 in the second table."}),"\n",(0,n.jsx)(t.li,{children:"Xdata totals 2k bits, comprising the upper section bits of x1, additional bits of x1, additional bits of x2, and match index for pairing x1 and x2, upper section bits of x3, additional bits of x3, additional bits of x4, and match index for pairing x3 and x4."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"E.g. if we have a k32, 6 section bits and 6 match bits, we form: [upper 6 bits of x1 and x2 (which are the same)][bits 7-16 of x1][bits 7-16 of x2][6 match index bits (applied to x1)][upper 6 bits of x3 and x4 (which are the same)][bits 7-16 of x3][bits 7-16 of x4][6 match index bits (applied to x3)]."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"EncryptedXs is the 2k-bits encrypted Xdata with a seed based on plot_id (reversible)"}),"\n",(0,n.jsx)(t.li,{children:"S is a random range within 0..2^2k based on the challenge"}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"the-challenge",children:"The Challenge"}),"\n",(0,n.jsx)(t.p,{children:"Find a proof where:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"The last 4 x values in the proof are converted to EncryptedX\u2019s and are in range S, and"}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"hash(challenge,EncryptedXs)"})," passes a filter (e.g. 1 in cardinality S chance will pass on average 1 result from this range)."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"In order to quickly satisfy the challenge for the plot, we store the sorted EncryptedXs in the second table, and drop the first table. This requires only 1 or 2 disk seeks to read the number of EncrpytedXs in the range S for the challenge."}),"\n",(0,n.jsx)(t.p,{children:"To reconstruct the original x values a farmer finds all possible values of buckets for x1 and x2 and finds a collision between them. In the k32 example above bits 17-32 of x1 and x2 are missing so there are 2^16 possibilities for each. To find the values a farmer makes a list of all 2^16 possibilities for one of the values (it doesn\u2019t matter which) then sorts it, then scans over all 2^16 possible values for the other looking up each one in the sorted list to see if it\u2019s there. For a farmer to store fewer bits they can drop bits from the EncryptedX, which doubles the amount of work necessary to be done. For them to need less work but more space they can store unencrypted x bits which halves the amount of work needed for each bit stored. Because there\u2019s an exponential increase in work per bit and computers are fast there\u2019s a range of bit dropping which has very little work even on low end hardware but where the costs of farming get prohibitive even on high end hardware with even a tiny increase in compression."}),"\n",(0,n.jsx)(t.p,{children:"The EncryptedXs scan filter forces a particular ordering and dataset in the plot format that severely limits the flexibility for an attacker to re-organize the data in a way to leverage particular bit dropping attacks."}),"\n",(0,n.jsx)(t.h3,{id:"random-x-quadruple-quality-filter",children:"Random x-quadruple quality filter"}),"\n",(0,n.jsx)(t.p,{children:"For each x1/2/3/4 set that passes the scan filter, find another random full x-quadruple in the proof based on the hash of those x\u2019s, the plot_id, and challenge. This x-quadruple then forms the value for the quality string that determines whether a good proof has been found."}),"\n",(0,n.jsx)(t.p,{children:"The additional random x-quadruple lookup ensures that all plot data is needed in order to find a quality by forcing a backwards traversal down the tables."}),"\n",(0,n.jsx)(t.h3,{id:"benefits",children:"Benefits"}),"\n",(0,n.jsx)(t.p,{children:"The plot id filter can be set lower, since the EncryptedXs scan filter only requires 1 or 2 disk lookups. A low plot id filter, combined with an additional filter on the EncryptedXs scan, forces rental attackers to generate at least the first two tables of a plot which require the most time, and then discard most of their results if it doesn\u2019t pass the scan filter. The scan filter also reduces the load on HDD disks by only passing a fraction of the time for the x-quadruple quality filter which requires more lookups."}),"\n",(0,n.jsx)(t.p,{children:"The combination of these three filters severely constrain the flexibility afforded to an attacker. The default level of bit dropping gives the honest farmer a baseline with negligible extra compute, but imposes an immediate difficulty for the attacker to compress much further without losing efficiency compared to the honest farmer."}),"\n",(0,n.jsx)(t.h2,{id:"benes-compression",children:"Benes Compression"}),"\n",(0,n.jsxs)(t.p,{children:["A new compression algorithm allows us to compress each table in the plot by 2-3 extra bits compared to the original format. Note that this is not bit dropping (which incurs costs that go up exponentially based on the amount of data being dropped), but rather an improved way to losslessly store information in each table. The findings are based on this ",(0,n.jsx)(t.a,{href:"https://hackmd.io/@dabo/rkP8Pcf9t",children:"blog post"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"In addition, Benes compression has the unique property that plot tables can be traversed in both directions, whereas the HDD friendly format requires additional data to store an index from the T2 table to the last table (so that it can then traverse entries down the table)."}),"\n",(0,n.jsx)(t.p,{children:"Each table in the plot using Benes compression comes at the cost of doing a few more random seeks in data retrieval. While it would be possible to put a few such Benes plots on an HDD, the proof retrieval times are not guaranteed to be completed in time. On SSD using Benes compression has minimal impact on farming and is the recommended storage format."}),"\n",(0,n.jsx)(t.p,{children:"While we hope to release Benes compression for plots prior to the hard fork, constructing the proof of space using the Benes algorithms is more challenging and could require significantly more RAM and slower plotting times."}),"\n",(0,n.jsx)(t.h2,{id:"further-compression-by-additional-bit-dropping",children:"Further Compression by Additional Bit Dropping"}),"\n",(0,n.jsx)(t.p,{children:"One of the first known compression attacks is to bit drop on x1/x2 pairs on the first table, and recompute for the missing range of values. With the new scan filter requiring both an encryption step on x-quadruples and a range to satisfy a challenge, any attacker wanting to alter which bits in those x-quadruples to drop, will forfeit compression they receive from the ordered encrypted values, and immediately require making up for k bits of lost compression. Likewise, any other attempts to re-organize x data for other bit dropping or compression methods will result in similar penalties."}),"\n",(0,n.jsx)(t.p,{children:"It is still possible to drop the lower-order bits from the EncryptedX values, where each bit dropped would require a doubling of compute. A potentially more advantageous approach is to leave the default x values intact and instead drop bits from the back pointers starting from table T3. In the original format, dropping two bits (one from each of the two back pointers in T3) would have saved approximately 1% of space, at the cost of doubling the time needed to recompute the quality string and the full proof."}),"\n",(0,n.jsx)(t.p,{children:"In the new format, we have restructured the back pointers, and currently, we see the potential to drop only 1 bit per back pointer for a doubling of compute. Further research may reveal the possibility of more aggressive bit dropping back up to 2 bits per doubling of recompute."}),"\n",(0,n.jsx)(t.p,{children:"As it stands, the default plot already includes a certain level of bit dropping, and bit dropping further quickly becomes too expensive. Depending on the final parameter settings, we don\u2019t expect this to be economically viable beyond a few bits on today\u2019s hardware, with each bit dropped saving ~0.5%. We will also offer the ability to plot using the most optimal method for further compression for those interested."}),"\n",(0,n.jsx)(t.h2,{id:"impact-to-honest-farmers",children:"Impact to Honest Farmers"}),"\n",(0,n.jsx)(t.p,{children:"The x values stored in T2 have default levels of bit-dropping already applied that are defined in the challenge scan filter. A small amount of compute is required when fetching a final quality string, similar to the low C-levels of the bladebit formats. The honest farmer will have to grind an additional small amount to get the full x values for the proof."}),"\n",(0,n.jsx)(t.p,{children:"There will also be an option to omit this low-level grinding if desired, at the cost of adding more bits to the plot format. However, since the compute required for the grind is low and designed to be close to optimal, the default level of bit dropping specified by the challenge is the recommended setting."}),"\n",(0,n.jsx)(t.h2,{id:"impact-to-rental-attacks",children:"Impact to Rental Attacks"}),"\n",(0,n.jsx)(t.p,{children:"Due to the long plotting time, lower plot id filter, and additional scan and x-quadruple filters that potentially throw away a newly created plot; rental attacks are no longer deemed to be a viable threat (>$1 billion per hour for an attack and will be well over 1000 times more expensive than the original format)."})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},9365:(e,t,i)=>{i.d(t,{A:()=>o});i(6540);var n=i(4164);const a={tabItem:"tabItem_Ymn6"};var r=i(4848);function o(e){let{children:t,hidden:i,className:o}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,n.A)(a.tabItem,o),hidden:i,children:t})}},1470:(e,t,i)=>{i.d(t,{A:()=>j});var n=i(6540),a=i(4164),r=i(3104),o=i(6347),s=i(205),l=i(7485),h=i(1682),d=i(679);function c(e){return n.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:t,children:i}=e;return(0,n.useMemo)((()=>{const e=t??function(e){return c(e).map((e=>{let{props:{value:t,label:i,attributes:n,default:a}}=e;return{value:t,label:i,attributes:n,default:a}}))}(i);return function(e){const t=(0,h.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,i])}function p(e){let{value:t,tabValues:i}=e;return i.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:i}=e;const a=(0,o.W6)(),r=function(e){let{queryString:t=!1,groupId:i}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:t,groupId:i});return[(0,l.aZ)(r),(0,n.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(a.location.search);t.set(r,e),a.replace({...a.location,search:t.toString()})}),[r,a])]}function m(e){const{defaultValue:t,queryString:i=!1,groupId:a}=e,r=u(e),[o,l]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:i}=e;if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${i.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=i.find((e=>e.default))??i[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:r}))),[h,c]=f({queryString:i,groupId:a}),[m,b]=function(e){let{groupId:t}=e;const i=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,r]=(0,d.Dv)(i);return[a,(0,n.useCallback)((e=>{i&&r.set(e)}),[i,r])]}({groupId:a}),g=(()=>{const e=h??m;return p({value:e,tabValues:r})?e:null})();(0,s.A)((()=>{g&&l(g)}),[g]);return{selectedValue:o,selectValue:(0,n.useCallback)((e=>{if(!p({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),b(e)}),[c,b,r]),tabValues:r}}var b=i(2303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=i(4848);function w(e){let{className:t,block:i,selectedValue:n,selectValue:o,tabValues:s}=e;const l=[],{blockElementScrollPositionUntilNextRender:h}=(0,r.a_)(),d=e=>{const t=e.currentTarget,i=l.indexOf(t),a=s[i].value;a!==n&&(h(t),o(a))},c=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const i=l.indexOf(e.currentTarget)+1;t=l[i]??l[0];break}case"ArrowLeft":{const i=l.indexOf(e.currentTarget)-1;t=l[i]??l[l.length-1];break}}t?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":i},t),children:s.map((e=>{let{value:t,label:i,attributes:r}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:n===t?0:-1,"aria-selected":n===t,ref:e=>l.push(e),onKeyDown:c,onClick:d,...r,className:(0,a.A)("tabs__item",g.tabItem,r?.className,{"tabs__item--active":n===t}),children:i??t},t)}))})}function v(e){let{lazy:t,children:i,selectedValue:r}=e;const o=(Array.isArray(i)?i:[i]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===r));return e?(0,n.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==r})))})}function y(e){const t=m(e);return(0,x.jsxs)("div",{className:(0,a.A)("tabs-container",g.tabList),children:[(0,x.jsx)(w,{...t,...e}),(0,x.jsx)(v,{...t,...e})]})}function j(e){const t=(0,b.A)();return(0,x.jsx)(y,{...e,children:c(e.children)},String(t))}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>s});var n=i(6540);const a={},r=n.createContext(a);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);