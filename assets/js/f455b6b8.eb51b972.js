"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[6229],{3073:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>r});var o=t(5893),i=t(1151);const s={title:"Coin Set vs Account Model",slug:"/coin-set-vs-account"},a=void 0,c={id:"coin-set-model/coin-set-vs-account",title:"Coin Set vs Account Model",description:"In the account model used in many blockchains such as Ethereum, Solana and Algorand, balances are kept in accounts. These are permanent data structures which do not get destroyed when they send funds.",source:"@site/docs/coin-set-model/coin-set-vs-account.md",sourceDirName:"coin-set-model",slug:"/coin-set-vs-account",permalink:"/coin-set-vs-account",draft:!1,unlisted:!1,editUrl:"https://github.com/Chia-Network/chia-docs/blob/main/docs/coin-set-model/coin-set-vs-account.md",tags:[],version:"current",frontMatter:{title:"Coin Set vs Account Model",slug:"/coin-set-vs-account"},sidebar:"tutorialSidebar",previous:{title:"Coin Set vs UTXO Model",permalink:"/coin-set-vs-utxo"},next:{title:"CLVM vs EVM",permalink:"/clvm-vs-evm"}},l={},r=[{value:"Ethereum&#39;s account model",id:"ethereums-account-model",level:2},{value:"Chia&#39;s coin set model",id:"chias-coin-set-model",level:2},{value:"Advantages of the account model",id:"advantages-of-the-account-model",level:2},{value:"Monetary fungibility",id:"monetary-fungibility",level:3},{value:"Account",id:"account",level:4},{value:"Coin set",id:"coin-set",level:4},{value:"Ease of programming",id:"ease-of-programming",level:3},{value:"Account",id:"account-1",level:4},{value:"Coin set",id:"coin-set-1",level:4},{value:"Advantages of the coin set model",id:"advantages-of-the-coin-set-model",level:2},{value:"Scalability",id:"scalability",level:3},{value:"Coin set",id:"coin-set-2",level:4},{value:"Account",id:"account-2",level:4},{value:"Privacy",id:"privacy",level:3},{value:"Coin set",id:"coin-set-3",level:4},{value:"Account",id:"account-3",level:4},{value:"Determinism",id:"determinism",level:3},{value:"Coin set",id:"coin-set-4",level:4},{value:"Account",id:"account-4",level:4},{value:"Sandboxing",id:"sandboxing",level:3},{value:"Coin set",id:"coin-set-5",level:4},{value:"Account",id:"account-5",level:4},{value:"Database size",id:"database-size",level:3},{value:"Coin set",id:"coin-set-6",level:4},{value:"Account",id:"account-6",level:4}];function d(e){const n={a:"a",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"In the account model used in many blockchains such as Ethereum, Solana and Algorand, balances are kept in accounts. These are permanent data structures which do not get destroyed when they send funds."}),"\n",(0,o.jsx)(n.p,{children:"In this section, we'll focus on Ethereum and how its account model compares with Chia's coin set model."}),"\n",(0,o.jsx)(n.h2,{id:"ethereums-account-model",children:"Ethereum's account model"}),"\n",(0,o.jsx)(n.p,{children:"In terms of keeping track of state, Ethereum's account model functions similarly to legacy banks. Accounts, balances and smart contracts are persisted on the blockchain."}),"\n",(0,o.jsx)(n.p,{children:"Accounts and contracts have money associated with them. The source code governing how money may be spent is a first class object."}),"\n",(0,o.jsx)(n.p,{children:"A typical Ethereum transaction would look like the following:"}),"\n",(0,o.jsx)(n.p,{children:"Alice wants to send 1 eth to Bob. To complete this transaction, 1 eth is subtracted from Alice's balance, and 1 eth is added to Bob's balance. There is no need to calculate the history of how Alice acquired 1 eth prior to this transaction. In order for the transaction to be processed, the system only needs to know that Alice's balance was at least 1 eth."}),"\n",(0,o.jsx)(n.h2,{id:"chias-coin-set-model",children:"Chia's coin set model"}),"\n",(0,o.jsxs)(n.p,{children:["There are no accounts or balances, but rather only coins (see the ",(0,o.jsx)(n.a,{href:"/coin-set-intro",children:"Coin Set Intro page"})," for more info). Coins are first class objects; they are the only data that is persisted on the blockchain. Each coin has a parent, allowing for its history to be tracked to its coinbase."]}),"\n",(0,o.jsx)(n.p,{children:"A typical Chia transaction would look like the following:"}),"\n",(0,o.jsx)(n.p,{children:"Alice wants to send 1 XCH to Bob. Alice has five coins in her wallet: four worth 0.2 XCH apiece, and one worth 0.7 XCH. Her wallet automatically selects two of the coins worth 0.2 XCH and the 0.7 XCH coin to be spent. All three coin spends happen simultaneously, along with two new coin creations: one worth 1 XCH which goes to Bob's wallet, and one worth 0.1 XCH which goes to Alice's wallet as \"change.\" Alice now has two coins worth 0.2 XCH and one worth 0.1 XCH. Bob has one coin worth 1 XCH. The total value owned by Alice and Bob has not changed -- it was 1.5 XCH both before and after the transaction was processed."}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Owner"}),(0,o.jsx)(n.th,{children:"Before"}),(0,o.jsx)(n.th,{children:"After"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Alice"}),(0,o.jsx)(n.td,{children:"1.5 XCH (5 coins)"}),(0,o.jsx)(n.td,{children:"0.5 XCH (3 coin)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Bob"}),(0,o.jsx)(n.td,{children:"0 XCH"}),(0,o.jsx)(n.td,{children:"1.0 XCH (1 coin)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{}),(0,o.jsx)(n.td,{}),(0,o.jsx)(n.td,{})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Total"}),(0,o.jsx)(n.td,{children:"1.5 XCH"}),(0,o.jsx)(n.td,{children:"1.5 XCH"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"advantages-of-the-account-model",children:"Advantages of the account model"}),"\n",(0,o.jsx)(n.h3,{id:"monetary-fungibility",children:"Monetary fungibility"}),"\n",(0,o.jsx)(n.h4,{id:"account",children:"Account"}),"\n",(0,o.jsx)(n.p,{children:'An account only has a balance, so it\'s difficult to make a logical case that some money should be treated differently than other money. Money is "mixed" by default.'}),"\n",(0,o.jsx)(n.h4,{id:"coin-set",children:"Coin set"}),"\n",(0,o.jsx)(n.p,{children:'Coins can be combined by spending them, but they cannot be "mixed" by adding a balance to an account. This means that some coins might be viewed differently than others, even if they have the same value.'}),"\n",(0,o.jsx)(n.p,{children:"This has already happened with Bitcoin. Due to its high energy consumption, some people have refused to buy bitcoins that can be traced to mining with fossil fuels. This affects Bitcoin's fungibility because not all coins are viewed equally."}),"\n",(0,o.jsx)(n.h3,{id:"ease-of-programming",children:"Ease of programming"}),"\n",(0,o.jsx)(n.h4,{id:"account-1",children:"Account"}),"\n",(0,o.jsx)(n.p,{children:"Solidity shares similar paradigms in programming to web development, so there is a large pool of programmers who can learn it fairly quickly. When programming a smart contract, the programmer can simply store all balances in an array. Transactions involve little more than adding to, and subtracting from, balances. All other logic is contained within the same program. It's simple to combine multiple transactions that affect the same program in the same block."}),"\n",(0,o.jsx)(n.h4,{id:"coin-set-1",children:"Coin set"}),"\n",(0,o.jsxs)(n.p,{children:["Transactions might involve spending and creating many coins, so a programmer must think about the rules governing how coins may be spent, and how coins will interact with each other. This makes programming in Chia more difficult than in Ethereum. However, auditing is much easier in Chia (see the ",(0,o.jsx)(n.a,{href:"/clvm-vs-evm",children:"CLVM vs EVM page"})," for more info)."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"advantages-of-the-coin-set-model",children:"Advantages of the coin set model"}),"\n",(0,o.jsx)(n.h3,{id:"scalability",children:"Scalability"}),"\n",(0,o.jsx)(n.h4,{id:"coin-set-2",children:"Coin set"}),"\n",(0,o.jsx)(n.p,{children:'Because verification is built into the coin set model, so is scaling. If a coin\'s "owner" loses the private key required to spend the coin, the coin becomes unspendable. However, the overall system is unaffected, so scaling does not become more difficult.'}),"\n",(0,o.jsx)(n.p,{children:"Additionally, because each coin spend is independent, the system is very parallelizable."}),"\n",(0,o.jsx)(n.h4,{id:"account-2",children:"Account"}),"\n",(0,o.jsx)(n.p,{children:"If an account's owner loses their private key, then any code or messages referring to that account cannot be processed. This can be propagated across the entire system, making solutions such as sharding more difficult."}),"\n",(0,o.jsx)(n.h3,{id:"privacy",children:"Privacy"}),"\n",(0,o.jsx)(n.h4,{id:"coin-set-3",children:"Coin set"}),"\n",(0,o.jsx)(n.p,{children:"With a click of a button, a user can add a new address for each transaction; each new coin can be stored in a different address. This makes blacklisting difficult."}),"\n",(0,o.jsx)(n.h4,{id:"account-3",children:"Account"}),"\n",(0,o.jsx)(n.p,{children:"Each user typically has just one account. It's possible to create additional accounts in order to use more than one address. However, high fees typically discourage users from doing this. Also, it's easy to blacklist an ETH address."}),"\n",(0,o.jsx)(n.h3,{id:"determinism",children:"Determinism"}),"\n",(0,o.jsx)(n.h4,{id:"coin-set-4",children:"Coin set"}),"\n",(0,o.jsx)(n.p,{children:"Coins can only be spent once, making the results deterministic (if you run the same program multiple times, you'll get the same result each time). Because of this, re-applying mempool transactions after a new block is not necessary."}),"\n",(0,o.jsxs)(n.p,{children:["Note, however, that smart coins ",(0,o.jsx)(n.em,{children:"could"})," be designed such that multiple people could spend the same coin, which would potentially reduce determinism for those coins."]}),"\n",(0,o.jsx)(n.h4,{id:"account-4",children:"Account"}),"\n",(0,o.jsx)(n.p,{children:"Multiple people can execute the same code within a smart contract. The order of execution could affect the results, which therefore reduces determinism."}),"\n",(0,o.jsx)(n.h3,{id:"sandboxing",children:"Sandboxing"}),"\n",(0,o.jsx)(n.h4,{id:"coin-set-5",children:"Coin set"}),"\n",(0,o.jsx)(n.p,{children:"Coin value is split between many coins, increasing sandboxing, and therefore security. One program cannot call or affect another. If a coin is hacked, only that coin's owner can have money stolen."}),"\n",(0,o.jsx)(n.h4,{id:"account-5",children:"Account"}),"\n",(0,o.jsx)(n.p,{children:"Value is stored within a single account or contract. Multiple people can execute the same smart contract code. If a contract is hacked, everyone who participates could have money stolen."}),"\n",(0,o.jsx)(n.h3,{id:"database-size",children:"Database size"}),"\n",(0,o.jsx)(n.h4,{id:"coin-set-6",children:"Coin set"}),"\n",(0,o.jsx)(n.p,{children:"Programmable features are not stored directly on chain. Instead, coins use hashing to allow for later verification of their contents."}),"\n",(0,o.jsx)(n.p,{children:"Chia's database is expected to grow by around 30 GB annually, which is roughly the same rate as Bitcoin's. Kryder's Law dictates that storage capacity will grow exponentially in the short-to-medium term, whereas the database will grow linearly. In early 2022, an SSD capable of storing Chia's database cost less than $50. This should hold true for the foreseeable future, even as Chia's database continues to expand."}),"\n",(0,o.jsx)(n.h4,{id:"account-6",children:"Account"}),"\n",(0,o.jsx)(n.p,{children:"User account information, as well as transaction data, is small. However, smart contracts are stored on chain. Because of this, Ethereum's database will likely grow more rapidly than Bitcoin's or Chia's."})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>a});var o=t(7294);const i={},s=o.createContext(i);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);