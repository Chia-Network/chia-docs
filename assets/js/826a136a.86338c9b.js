"use strict";(globalThis.webpackChunkchia_docs=globalThis.webpackChunkchia_docs||[]).push([[3853],{3132(e,s,n){n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"chia-blockchain/protocol/wallet-protocol","title":"Wallet Protocol","description":"Wallet protocol source","source":"@site/docs/chia-blockchain/protocol/wallet-protocol.md","sourceDirName":"chia-blockchain/protocol","slug":"/chia-blockchain/protocol/wallet-protocol","permalink":"/chia-blockchain/protocol/wallet-protocol","draft":false,"unlisted":false,"editUrl":"https://github.com/Chia-Network/chia-docs/blob/main/docs/chia-blockchain/protocol/wallet-protocol.md","tags":[],"version":"current","frontMatter":{"title":"Wallet Protocol","slug":"/chia-blockchain/protocol/wallet-protocol"},"sidebar":"tutorialSidebar","previous":{"title":"Pool Protocol 1.0 Specification","permalink":"/chia-blockchain/protocol/pool/pool-protocol-specification"},"next":{"title":"Intro to Cryptocurrencies","permalink":"/chia-blockchain/resources/cryptocurrency-intro"}}');var o=n(4848),i=n(8453);const r={title:"Wallet Protocol",slug:"/chia-blockchain/protocol/wallet-protocol"},l=void 0,a={},c=[{value:"Privacy Protocol",id:"privacy-protocol",level:2},{value:"Fast Sync Protocol (recommended)",id:"fast-sync-protocol-recommended",level:2},{value:"request_puzzle_solution",id:"request_puzzle_solution",level:2},{value:"respond_puzzle_solution",id:"respond_puzzle_solution",level:2},{value:"reject_puzzle_solution",id:"reject_puzzle_solution",level:2},{value:"send_transaction",id:"send_transaction",level:2},{value:"transaction_ack",id:"transaction_ack",level:2},{value:"new_peak_wallet",id:"new_peak_wallet",level:2},{value:"request_block_header",id:"request_block_header",level:2},{value:"respond_block_header",id:"respond_block_header",level:2},{value:"request_block_headers",id:"request_block_headers",level:2},{value:"respond_block_headers",id:"respond_block_headers",level:2},{value:"reject_block_headers",id:"reject_block_headers",level:2},{value:"reject_header_request",id:"reject_header_request",level:2},{value:"request_removals",id:"request_removals",level:2},{value:"respond_removals",id:"respond_removals",level:2},{value:"reject_removals_request",id:"reject_removals_request",level:2},{value:"request_additions",id:"request_additions",level:2},{value:"respond_additions",id:"respond_additions",level:2},{value:"reject_additions_request",id:"reject_additions_request",level:2},{value:"request_header_blocks",id:"request_header_blocks",level:2},{value:"reject_header_blocks",id:"reject_header_blocks",level:2},{value:"respond_header_blocks",id:"respond_header_blocks",level:2},{value:"register_for_ph_updates",id:"register_for_ph_updates",level:2},{value:"respond_to_ph_updates",id:"respond_to_ph_updates",level:2},{value:"register_for_coin_updates",id:"register_for_coin_updates",level:2},{value:"respond_to_coin_updates",id:"respond_to_coin_updates",level:2},{value:"coin_state_update",id:"coin_state_update",level:2},{value:"request_children",id:"request_children",level:2},{value:"respond_children",id:"respond_children",level:2},{value:"request_ses_info",id:"request_ses_info",level:2},{value:"respond_ses_info",id:"respond_ses_info",level:2},{value:"request_remove_puzzle_subscriptions",id:"request_remove_puzzle_subscriptions",level:2},{value:"respond_remove_puzzle_subscriptions",id:"respond_remove_puzzle_subscriptions",level:2},{value:"request_remove_coin_subscriptions",id:"request_remove_coin_subscriptions",level:2},{value:"respond_remove_coin_subscriptions",id:"respond_remove_coin_subscriptions",level:2},{value:"request_puzzle_state",id:"request_puzzle_state",level:2},{value:"respond_puzzle_state",id:"respond_puzzle_state",level:2},{value:"reject_puzzle_state",id:"reject_puzzle_state",level:2},{value:"request_coin_state",id:"request_coin_state",level:2},{value:"respond_coin_state",id:"respond_coin_state",level:2},{value:"reject_coin_state",id:"reject_coin_state",level:2},{value:"mempool_items_added",id:"mempool_items_added",level:2},{value:"mempool_items_removed",id:"mempool_items_removed",level:2},{value:"request_cost_info",id:"request_cost_info",level:2},{value:"respond_cost_info",id:"respond_cost_info",level:2}];function d(e){const s={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.p,{children:(0,o.jsx)(s.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/main/chia/protocols/wallet_protocol.py",children:"Wallet protocol source"})}),"\n",(0,o.jsx)(s.p,{children:"This protocol is a bidirectional protocol for communication between full nodes and wallets in the Chia system.\nThis is also sometimes referred to as the light client protocol."}),"\n",(0,o.jsx)(s.p,{children:"The wallet protocol contains two sub protocols by which a wallet can sync transaction from a node."}),"\n",(0,o.jsx)(s.h2,{id:"privacy-protocol",children:"Privacy Protocol"}),"\n",(0,o.jsx)(s.p,{children:"The first is the privacy protocol, where the wallet downloads each header and checks the filter for transactions. It is more private,\nbut much slower."}),"\n",(0,o.jsx)(s.h2,{id:"fast-sync-protocol-recommended",children:"Fast Sync Protocol (recommended)"}),"\n",(0,o.jsx)(s.p,{children:"The second is the fast sync protocol, where the wallet directly asks the node to look for certain coin ids or puzzle\nhashes. It has less privacy but is much faster. The following is the flow for syncing for a wallet that any wallet\ndeveloper should follow. It is important to connect to several random nodes to increase security. This sync protocol\nshould be very fast for users who don't have many transactions."}),"\n",(0,o.jsxs)(s.ol,{children:["\n",(0,o.jsxs)(s.li,{children:["Perform a DNS lookup to obtain random node IPS: ",(0,o.jsx)(s.code,{children:"dig dns-introducer.chia.net"}),"."]}),"\n",(0,o.jsxs)(s.li,{children:["Connect to a few nodes, to ensure the server does not omit transactions. The nodes will send a ",(0,o.jsx)(s.code,{children:"new_peak_wallet"})," message with their claimed peaks."]}),"\n",(0,o.jsx)(s.li,{children:"Download a weight proof from one of the nodes (or several) with the heaviest peak"}),"\n",(0,o.jsx)(s.li,{children:"Verify the weight proof to make sure the claimed peak is correct"}),"\n",(0,o.jsx)(s.li,{children:"Subscribe to first 100 puzzle hashes for our key (both observer and non-observer)"}),"\n",(0,o.jsx)(s.li,{children:"Validate the puzzle hash subscription state returned from the full node. This requires making sure the block in which these coins are included is part of the chain of SubEpochSummaries. Only the block hashes have to be checked here. Furthermore, a few block headers (around 30-50) should be validated after this block to make sure it is properly buried."}),"\n",(0,o.jsx)(s.li,{children:"From step 5, we obtain all coin IDs which we are interested in, and we restore any CAT wallets for coins which have our puzzle hash in the hint."}),"\n",(0,o.jsx)(s.li,{children:"Subscribe to interesting coin IDs"}),"\n",(0,o.jsx)(s.li,{children:"Validate the coin subscription returned from the full node, similar to how it's done in step 5"}),"\n"]}),"\n",(0,o.jsx)(s.h1,{id:"protocol-messages",children:"Protocol Messages"}),"\n",(0,o.jsx)(s.h2,{id:"request_puzzle_solution",children:"request_puzzle_solution"}),"\n",(0,o.jsx)(s.p,{children:"A request from the wallet to the full node for the puzzle and solution of a certain spent coin ID."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestPuzzleSolution(Streamable):\n    coin_name: bytes32  # ID of the spent coin\n    height: uint32      # Spent height\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_puzzle_solution",children:"respond_puzzle_solution"}),"\n",(0,o.jsxs)(s.p,{children:["A response to a ",(0,o.jsx)(s.code,{children:"request_puzzle_solution"})," request."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"\nclass RespondPuzzleSolution(Streamable):\n    response: PuzzleSolutionResponse\n\nclass PuzzleSolutionResponse(Streamable):\n    coin_name: bytes32\n    height: uint32\n    puzzle: Program\n    solution: Program\n"})}),"\n",(0,o.jsx)(s.h2,{id:"reject_puzzle_solution",children:"reject_puzzle_solution"}),"\n",(0,o.jsxs)(s.p,{children:["A rejection to a ",(0,o.jsx)(s.code,{children:"request_puzzle_solution"})," request."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RejectPuzzleSolution(Streamable):\n    coin_name: bytes32\n    height: uint32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"send_transaction",children:"send_transaction"}),"\n",(0,o.jsx)(s.p,{children:"A message by which a wallet can send a transaction to the mempool and broadcast it to the network. The full node\nwill attempt to include it into the mempool."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class SendTransaction(Streamable):\n    transaction: SpendBundle\n"})}),"\n",(0,o.jsx)(s.h2,{id:"transaction_ack",children:"transaction_ack"}),"\n",(0,o.jsxs)(s.p,{children:["A response to a ",(0,o.jsx)(s.code,{children:"send_transaction"})," message. After attempting to include the transaction, the mempool inclusion status\nis returned, with an optional english error string in case it did not succeed."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class MempoolInclusionStatus(IntEnum):\n    SUCCESS = 1  # Transaction added to mempool\n    PENDING = 2  # Transaction not yet added to mempool\n    FAILED = 3  # Transaction was invalid and dropped\n\nclass TransactionAck(Streamable):\n    txid: bytes32\n    status: uint8  # MempoolInclusionStatus\n    error: Optional[str]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"new_peak_wallet",children:"new_peak_wallet"}),"\n",(0,o.jsx)(s.p,{children:"A notification from the full node to the wallet that the blockchain's peak has changed."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class NewPeakWallet(Streamable):\n    header_hash: bytes32       # New peak of the blockchain\n    height: uint32             # New peak's height\n    weight: uint128            # New peak's weight\n    fork_point_with_previous_peak: uint32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"request_block_header",children:"request_block_header"}),"\n",(0,o.jsx)(s.p,{children:"A request from the wallet to the full node for a HeaderBlock at a specific height."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestBlockHeader(Streamable):\n    height: uint32  # Height of the header block\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_block_header",children:"respond_block_header"}),"\n",(0,o.jsxs)(s.p,{children:["A response to a ",(0,o.jsx)(s.code,{children:"request_block_header"})," request."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondBlockHeader(Streamable):\n    header_block: HeaderBlock\n"})}),"\n",(0,o.jsx)(s.h2,{id:"request_block_headers",children:"request_block_headers"}),"\n",(0,o.jsxs)(s.p,{children:["A request from the wallet to the full node for a HeaderBlock at a specific height.",(0,o.jsx)(s.br,{}),"\n","NOTE: this message deprecates and replaces ",(0,o.jsx)(s.code,{children:"request_header_blocks"})," (flip block and header)."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestBlockHeaders(Streamable):\n    height: uint32  # Height of the header block\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_block_headers",children:"respond_block_headers"}),"\n",(0,o.jsxs)(s.p,{children:["A response to a ",(0,o.jsx)(s.code,{children:"request_block_headers"})," request.",(0,o.jsx)(s.br,{}),"\n","NOTE: this message deprecates and replaces ",(0,o.jsx)(s.code,{children:"respond_header_blocks"})," (flip block and header)."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondBlockHeaders(Streamable):\n    header_block: HeaderBlock\n"})}),"\n",(0,o.jsx)(s.h2,{id:"reject_block_headers",children:"reject_block_headers"}),"\n",(0,o.jsxs)(s.p,{children:["A rejection to a ",(0,o.jsx)(s.code,{children:"request_block_headers"})," request.",(0,o.jsx)(s.br,{}),"\n","NOTE: this message deprecates and replaces ",(0,o.jsx)(s.code,{children:"reject_header_blocks"})," (flip block and header)."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RejectBlockHeaders(Streamable):\n    start_height: uint32\n    end_height: uint32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"reject_header_request",children:"reject_header_request"}),"\n",(0,o.jsxs)(s.p,{children:["A rejection to a ",(0,o.jsx)(s.code,{children:"request_block_header"})," request."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RejectHeaderRequest(Streamable):\n    height: uint32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"request_removals",children:"request_removals"}),"\n",(0,o.jsxs)(s.p,{children:["A request from the wallet to the full node for the removals (removed coins) of a certain block. If ",(0,o.jsx)(s.code,{children:"coin_names"})," is None,\nwe are requesting all removals in the block. Otherwise, we are requesting only these specific removal coin IDs."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestRemovals(Streamable):\n    height: uint32        # Height of the block\n    header_hash: bytes32  # Header hash of the block\n    coin_names: Optional[List[bytes32]]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_removals",children:"respond_removals"}),"\n",(0,o.jsxs)(s.p,{children:["A response to a ",(0,o.jsx)(s.code,{children:"request_removals"})," request. If ",(0,o.jsx)(s.code,{children:"coin_names"})," is None, all removals are returned, and ",(0,o.jsx)(s.code,{children:"proofs"})," is set\nto None. Otherwise, only the requested coins are returned, (id to coin tuples) and a proof is returned for each\ncoin id (id to proof tuples). The proofs are merkle set inclusion proofs. See ",(0,o.jsx)(s.code,{children:"merkle_set.py"})," in chia-blockchain\nfor more info on how to verify these proofs."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondRemovals(Streamable):\n    height: uint32\n    header_hash: bytes32\n    coins: List[Tuple[bytes32, Optional[Coin]]]\n    proofs: Optional[List[Tuple[bytes32, bytes]]]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"reject_removals_request",children:"reject_removals_request"}),"\n",(0,o.jsxs)(s.p,{children:["A rejection to a ",(0,o.jsx)(s.code,{children:"request_removals"})," request."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RejectRemovalsRequest(Streamable):\n    height: uint32\n    header_hash: bytes32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"request_additions",children:"request_additions"}),"\n",(0,o.jsxs)(s.p,{children:["A request from the wallet to the full node for the additions (added coins) of a certain block. If ",(0,o.jsx)(s.code,{children:"puzzle_hashes"})," is\nNone, we are requesting all additions in the block. Otherwise, we are requesting only additions which have this puzzle hash."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestAdditions(Streamable):\n    height: uint32\n    header_hash: Optional[bytes32]\n    puzzle_hashes: Optional[List[bytes32]]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_additions",children:"respond_additions"}),"\n",(0,o.jsxs)(s.p,{children:["A response to a ",(0,o.jsx)(s.code,{children:"request_additions"})," request. If ",(0,o.jsx)(s.code,{children:"puzzle_hashes"})," is None, all additions are returned, and ",(0,o.jsx)(s.code,{children:"proofs"})," is set\nto None. Otherwise, only the requested coins are returned, (puzzle_hash to list of coin tuples, since multiple coins\ncan have the same puzzle hash) and a proof is returned for each\ncoin (puzzle_hash, proof, proof2 tuples). The proofs are merkle set inclusion proofs. See ",(0,o.jsx)(s.code,{children:"merkle_set.py"})," in chia-blockchain\nfor more info on how to verify these proofs. ",(0,o.jsx)(s.code,{children:"proof"})," refers to a proof of the puzzle hash in the merkle set, and\n",(0,o.jsx)(s.code,{children:"proof2"})," is the merkle proof of ",(0,o.jsx)(s.code,{children:"sha256(concatenation of coin ids)"})," for each puzzle hash, in the merkle set. Both are\nincluded as elements in the merkle set for each block."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondAdditions(Streamable):\n    height: uint32\n    header_hash: bytes32\n    coins: List[Tuple[bytes32, List[Coin]]]     # puzzle hash => List[Coin] with that puzzle hash\n    proofs: Optional[List[Tuple[bytes32, bytes, Optional[bytes]]]]  # Puzzle hash. proof, proof2\n"})}),"\n",(0,o.jsx)(s.h2,{id:"reject_additions_request",children:"reject_additions_request"}),"\n",(0,o.jsxs)(s.p,{children:["A rejection to a ",(0,o.jsx)(s.code,{children:"request_additions"})," request"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RejectAdditionsRequest(Streamable):\n    height: uint32\n    header_hash: bytes32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"request_header_blocks",children:"request_header_blocks"}),"\n",(0,o.jsxs)(s.p,{children:["DEPRECATED: this message has been deprecated and replaced with ",(0,o.jsx)(s.code,{children:"request_block_headers"})," (flip block and header).",(0,o.jsx)(s.br,{}),"\n","A request from the wallet to the full node for a list of consecutive header blocks, inclusive."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestHeaderBlocks(Streamable):\n    start_height: uint32\n    end_height: uint32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"reject_header_blocks",children:"reject_header_blocks"}),"\n",(0,o.jsxs)(s.p,{children:["DEPRECATED: this message has been deprecated and replaced with ",(0,o.jsx)(s.code,{children:"reject_block_headers"})," (flip block and header).",(0,o.jsx)(s.br,{}),"\n","A rejection for a ",(0,o.jsx)(s.code,{children:"request_header_blocks"})," request."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RejectHeaderBlocks(Streamable):\n    start_height: uint32\n    end_height: uint32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_header_blocks",children:"respond_header_blocks"}),"\n",(0,o.jsxs)(s.p,{children:["DEPRECATED: this message has been deprecated and replaced with ",(0,o.jsx)(s.code,{children:"respond_block_headers"})," (flip block and header).",(0,o.jsx)(s.br,{}),"\n","A response to a ",(0,o.jsx)(s.code,{children:"request_header_blocks"})," request."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondHeaderBlocks(Streamable):\n    start_height: uint32\n    end_height: uint32\n    header_blocks: List[HeaderBlock]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"register_for_ph_updates",children:"register_for_ph_updates"}),"\n",(0,o.jsxs)(s.p,{children:["A request from the wallet to the full node to register for updates to a puzzle hash. This is part of the fast sync\nprotocol. Whenever a new coin with one of these puzzle hashes (or hint) is created or spent, the full node will send a notification\nto the wallet (",(0,o.jsx)(s.code,{children:"coin_state_update"}),"). Also, a one time notification is sent back with all the updates (",(0,o.jsx)(s.code,{children:"respond_to_ph_updates"}),")."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RegisterForPhUpdates(Streamable):\n    puzzle_hashes: List[bytes32]\n    min_height: uint32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_to_ph_updates",children:"respond_to_ph_updates"}),"\n",(0,o.jsxs)(s.p,{children:["A one-time response to ",(0,o.jsx)(s.code,{children:"register_for_ph_updates"})," with all the confirmation or spent heights, and all the CoinStates.\nCoinState is an object that shows a change in a coin. if ",(0,o.jsx)(s.code,{children:"spent_height"})," is not None, that means the coin was spent.\nIf ",(0,o.jsx)(s.code,{children:"created_height"})," is not None, that means the coin was created but not spent. If both are None, it means the\ncoin was reverted (reorged out of the chain) and no longer exists."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondToPhUpdates(Streamable):\n    puzzle_hashes: List[bytes32]\n    min_height: uint32\n    coin_states: List[CoinState]\n\nclass CoinState(Streamable):\n    coin: Coin\n    spent_height: Optional[uint32]\n    created_height: Optional[uint32]\n`\n"})}),"\n",(0,o.jsx)(s.h2,{id:"register_for_coin_updates",children:"register_for_coin_updates"}),"\n",(0,o.jsxs)(s.p,{children:["A request from the wallet to the full node to register for updates to a coin ID. This is part of the fast sync\nprotocol. Whenever a new coin with one of these coin IDs is created or spent, the full node will send a notification\nto the wallet (",(0,o.jsx)(s.code,{children:"coin_state_update"}),"). Also, a one time notification is sent back with all the updates (",(0,o.jsx)(s.code,{children:"respond_to_coin_updates"}),")."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RegisterForCoinUpdates(Streamable):\n    coin_ids: List[bytes32]\n    min_height: uint32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_to_coin_updates",children:"respond_to_coin_updates"}),"\n",(0,o.jsxs)(s.p,{children:["A one-time response to ",(0,o.jsx)(s.code,{children:"register_for_coin_updates"})," with all the confirmation or spent heights, and all the CoinStates."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondToCoinUpdates(Streamable):\n    coin_ids: List[bytes32]\n    min_height: uint32\n    coin_states: List[CoinState]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"coin_state_update",children:"coin_state_update"}),"\n",(0,o.jsx)(s.p,{children:"This is an update but not in response to a request. The full node will send the update whenever a new block\nis confirmed which contains removals or additions that are interesting to the wallet."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class CoinStateUpdate(Streamable):\n    height: uint32\n    fork_height: uint32\n    peak_hash: bytes32\n    items: List[CoinState]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"request_children",children:"request_children"}),"\n",(0,o.jsx)(s.p,{children:"A request from the wallet to the node for the children of a certain (spent) coin ID."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestChildren(Streamable):\n    coin_name: bytes32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_children",children:"respond_children"}),"\n",(0,o.jsxs)(s.p,{children:["A response to a ",(0,o.jsx)(s.code,{children:"request_children"})," request."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondChildren(Streamable):\n    coin_states: List[CoinState]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"request_ses_info",children:"request_ses_info"}),"\n",(0,o.jsx)(s.p,{children:"A request from the wallet to the full node for SubEpochSummary heights. This is used for the fast sync protocol,\nto know where sub epochs start and end."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestSESInfo(Streamable):\n    start_height: uint32\n    end_height: uint32\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_ses_info",children:"respond_ses_info"}),"\n",(0,o.jsxs)(s.p,{children:["A response to a ",(0,o.jsx)(s.code,{children:"request_ses_info"})," request."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondSESInfo(Streamable):\n    reward_chain_hash: List[bytes32]\n    heights: List[List[uint32]]\n"})}),"\n",(0,o.jsx)(s.admonition,{type:"note",children:(0,o.jsxs)(s.p,{children:["The below messages have been added via ",(0,o.jsx)(s.a,{href:"https://github.com/Chia-Network/chips/blob/8a597d06988eb308aa13488c5916ec041f39bc74/CHIPs/chip-0026.md",children:"Chip 26"}),".\nThese have been added to the reference ",(0,o.jsx)(s.a,{href:"https://github.com/Chia-Network/chia-blockchain/blob/main/chia/protocols/wallet_protocol.py",children:"node codebase"})," but have not been implemented in the reference wallet as of January 2025."]})}),"\n",(0,o.jsx)(s.h2,{id:"request_remove_puzzle_subscriptions",children:"request_remove_puzzle_subscriptions"}),"\n",(0,o.jsx)(s.p,{children:"Removes puzzle hashes from the subscription list (or all of them if None)."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestRemovePuzzleSubscriptions:\n    puzzle_hashes: Optional[List[bytes32]]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_remove_puzzle_subscriptions",children:"respond_remove_puzzle_subscriptions"}),"\n",(0,o.jsx)(s.p,{children:"Returns the hashes that were actually removed."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondRemovePuzzleSubscriptions:\n    puzzle_hashes: List[bytes32]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"request_remove_coin_subscriptions",children:"request_remove_coin_subscriptions"}),"\n",(0,o.jsx)(s.p,{children:"Removes coin ids from the subscription list (or all of them if None)"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestRemoveCoinSubscriptions:\n    coin_ids: Optional[List[bytes32]]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_remove_coin_subscriptions",children:"respond_remove_coin_subscriptions"}),"\n",(0,o.jsx)(s.p,{children:"Returns the ids that were actually removed."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondRemoveCoinSubscriptions:\n    coin_ids: List[bytes32]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"request_puzzle_state",children:"request_puzzle_state"}),"\n",(0,o.jsxs)(s.p,{children:["Requests coin states that match the given puzzle hashes (or hints).",(0,o.jsx)(s.br,{}),"\n","When subscribe is set to True, it will add and return as many coin ids to the subscriptions list as possible.",(0,o.jsx)(s.br,{}),"\n","When subscribe is set to True and mempool updates are enabled (can be done during the handshake) mempool update messages will be sent (including an initial MempoolItemsAdded message when you subscribe for the first time).\nFilter out spent, unspent, or hinted coins, as well as coins below a minimum amount."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestPuzzleState:\n    puzzle_hashes: List[bytes32]\n    previous_height: Optional[uint32]\n    header_hash: bytes32\n    filters: CoinStateFilters\n    subscribe_when_finished: bool\n\nclass CoinStateFilters:\n    include_spent: bool\n    include_unspent: bool\n    include_hinted: bool\n    min_amount: uint64\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_puzzle_state",children:"respond_puzzle_state"}),"\n",(0,o.jsx)(s.p,{children:"Responds with coin states that match the given puzzle hashes (or hints)."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondPuzzleState:\n    puzzle_hashes: List[bytes32]\n    height: uint32\n    header_hash: bytes32\n    is_finished: bool\n    coin_states: List[CoinState]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"reject_puzzle_state",children:"reject_puzzle_state"}),"\n",(0,o.jsx)(s.p,{children:"Reject request_puzzle_state in the event that a reorg is detected by a node, this is the only scenario it will be rejected like this."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RejectPuzzleState:\n    reason: uint8  # RejectStateReason\n\n\nclass RejectStateReason(IntEnum):\n    REORG = 0\n    EXCEEDED_SUBSCRIPTION_LIMIT = 1\n"})}),"\n",(0,o.jsx)(s.h2,{id:"request_coin_state",children:"request_coin_state"}),"\n",(0,o.jsxs)(s.p,{children:["Request coin states that match the given coin ids.",(0,o.jsx)(s.br,{}),"\n","When subscribe is set to True, it will add and return as many coin ids to the subscriptions list as possible.",(0,o.jsx)(s.br,{}),"\n","When subscribe is set to True and mempool updates are enabled (can be done during the handshake) mempool update messages will be sent (including an initial MempoolItemsAdded message when you subscribe for the first time)."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestCoinState:\n    coin_ids: List[bytes32]\n    previous_height: Optional[uint32]\n    header_hash: bytes32\n    subscribe: bool\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_coin_state",children:"respond_coin_state"}),"\n",(0,o.jsxs)(s.p,{children:["Respond with coin states that match the given coin ids.",(0,o.jsx)(s.br,{}),"\n","This does not implement batching for simplicity. The order is also not guaranteed. However, you can still specify the previous_height and header_hash to start."]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondCoinState:\n    coin_ids: List[bytes32]\n    coin_states: List[CoinState]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"reject_coin_state",children:"reject_coin_state"}),"\n",(0,o.jsx)(s.p,{children:"Reject request_coin_state in the event that a reorg is detected by a node, this is the only scenario it will be rejected like this."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RejectCoinState:\n    reason: uint8  # RejectStateReason\n\nclass RejectStateReason(IntEnum):\n    REORG = 0\n    EXCEEDED_SUBSCRIPTION_LIMIT = 1\n"})}),"\n",(0,o.jsx)(s.h2,{id:"mempool_items_added",children:"mempool_items_added"}),"\n",(0,o.jsx)(s.p,{children:"The below mempool update messages (including an initial MempoolItemsAdded message when you subscribe for the first time) are received when:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"request_coin_state"})," or ",(0,o.jsx)(s.code,{children:"request_puzzle_state"})," messages are sent,"]}),"\n",(0,o.jsx)(s.li,{children:"AND subscribe is set to True in the request,"}),"\n",(0,o.jsx)(s.li,{children:"AND mempool updates are enabled (can be done during the handshake)."}),"\n"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class MempoolItemsAdded:\n    transaction_ids: List[bytes32]\n"})}),"\n",(0,o.jsx)(s.h2,{id:"mempool_items_removed",children:"mempool_items_removed"}),"\n",(0,o.jsx)(s.p,{children:"The below mempool update messages (including an initial MempoolItemsAdded message when you subscribe for the first time) are received when:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.code,{children:"request_coin_state"})," or ",(0,o.jsx)(s.code,{children:"request_puzzle_state"})," messages are sent,"]}),"\n",(0,o.jsx)(s.li,{children:"AND subscribe is set to True in the request,"}),"\n",(0,o.jsx)(s.li,{children:"AND mempool updates are enabled (can be done during the handshake)."}),"\n"]}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class MempoolItemsRemoved:\n    removed_items: List[RemovedMempoolItem]\n\nclass RemovedMempoolItem:\n    transaction_id: bytes32\n    reason: uint8 # MempoolRemoveReason\n\nclass MempoolRemoveReason(Enum):\n    CONFLICT = 1\n    BLOCK_INCLUSION = 2\n    POOL_FULL = 3\n    EXPIRED = 4\n"})}),"\n",(0,o.jsx)(s.h2,{id:"request_cost_info",children:"request_cost_info"}),"\n",(0,o.jsx)(s.p,{children:"Request various information about the costs of transactions, blocks, and the mempool."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RequestCostInfo:\n    pass\n"})}),"\n",(0,o.jsx)(s.h2,{id:"respond_cost_info",children:"respond_cost_info"}),"\n",(0,o.jsx)(s.p,{children:"Respond with various information about the costs of transactions, blocks, and the mempool."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"class RespondCostInfo:\n    max_transaction_cost: uint64\n    max_block_cost: uint64\n    max_mempool_cost: uint64\n    mempool_cost: uint64\n    mempool_fee: uint64\n    bump_fee_per_cost: uint8\n"})})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,s,n){n.d(s,{R:()=>r,x:()=>l});var t=n(6540);const o={},i=t.createContext(o);function r(e){const s=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);