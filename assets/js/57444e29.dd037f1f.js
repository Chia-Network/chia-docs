"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[9498],{8159:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>h});var n=s(5893),i=s(1151);const o={title:"Overflow Blocks and Weight",slug:"/overflow-blocks"},a=void 0,r={id:"consensus/overflow-blocks",title:"Overflow Blocks and Weight",description:"Overflow Blocks",source:"@site/docs/consensus/overflow-blocks.md",sourceDirName:"consensus",slug:"/overflow-blocks",permalink:"/overflow-blocks",draft:!1,unlisted:!1,editUrl:"https://github.com/Chia-Network/chia-docs/blob/main/docs/consensus/overflow-blocks.md",tags:[],version:"current",frontMatter:{title:"Overflow Blocks and Weight",slug:"/overflow-blocks"},sidebar:"tutorialSidebar",previous:{title:"Three VDF Chains",permalink:"/three-vdf-chains"},next:{title:"Foliage",permalink:"/consensus-foliage"}},l={},h=[{value:"Overflow Blocks",id:"overflow-blocks",level:2},{value:"Minimum Block Requirement",id:"minimum-block-requirement",level:2},{value:"Weight",id:"weight",level:2}];function c(e){const t={a:"a",h2:"h2",p:"p",strong:"strong",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h2,{id:"overflow-blocks",children:"Overflow Blocks"}),"\n",(0,n.jsxs)(t.p,{children:["For a farmer to create a block, their required_iterations must be less than sub-slot_iterations / 64, as described in the ",(0,n.jsx)(t.a,{href:"/signage-and-infusion-points",children:"Signage and Infusion Points page"}),". This means that infusion_iterations might be greater than the sub-slot_iterations, and therefore the infusion must happen in the next sub-slot."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Overflow block"}),": a block whose infusion point is in a different sub-slot than its signage point."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Current-slot challenge"}),": Any given block's current-slot challenges include all\nchallenges starting at the first challenge in the slot, and ending at the end of the slot (non-inclusive).\nThis is relevant because sometimes a slot spans multiple sub-slots, and thus multiple challenges."]}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("img",{src:"/img/overflow.png",alt:"drawing"}),(0,n.jsxs)("figcaption",{children:[(0,n.jsx)(t.p,{children:"Figure 9: B4 in this diagram is an overflow block, since the infusion is in the next sub-slot."}),(0,n.jsx)(t.p,{children:"B4 is not based on a current-slot challenge, and thus does not decrease the deficit or make a challenge block."})]})]}),"\n",(0,n.jsx)(t.p,{children:"Overflow blocks cannot exist in the first sub-slot of the epoch (since the sub-slot iterations change)."}),"\n",(0,n.jsx)(t.p,{children:"Also, overflow blocks do not change the deficit unless they are based on a current-slot challenge, since overflow blocks are responses to the previous sub-slot's challenge. Overflow blocks are not challenge blocks unless they are based on a current-slot challenge. Note that it is rare for overflow blocks to decrease the deficit, since the deficit will almost always be decreased to zero, and a new slot will be started on every sub-slot."}),"\n",(0,n.jsx)(t.h2,{id:"minimum-block-requirement",children:"Minimum Block Requirement"}),"\n",(0,n.jsx)(t.p,{children:"A minimum of 16 current-slot challenge blocks must be infused into the rewards chain in order for a slot to be finished. (Recall that a sub-slot has no such requirement, so a slot could span multiple sub-slots.)"}),"\n",(0,n.jsx)(t.p,{children:"The deficit is a number between 0 and 16 that is present at the start of a sub-slot, and is present for each finished block. This is defined as the number of reward chain blocks that we need to infuse in order to finish a slot. It is reset to 16 whenever we start a slot (so there must be at least 16 total blocks per challenge chain infusion). The deficit goes down for each reward chain infusion that is based on a current-slot challenge."}),"\n",(0,n.jsx)(t.p,{children:"The block with deficit 15 is a challenge block."}),"\n",(0,n.jsx)(t.p,{children:"The normal case is where the deficit starts at 16, and goes down to zero within the sub-slot, and resets back to 16 as we finish the slot and start a new one. In the case that we don't manage to reduce it to 0 within the end of the sub-slot, the challenge chain and infused challenge chain (if present) continue, and the deficit does not reset to 16. Blocks (including overflow blocks now), keep subtracting from the deficit until we reach 0. When we finish a sub-slot with a zero deficit, the infused challenge chain is included into the challenge chain, and the deficit is reset to 16."}),"\n",(0,n.jsxs)(t.p,{children:["This requirement was added to discourage long-range attacks, and is described in detail in the ",(0,n.jsx)(t.a,{href:"/consensus-attacks#majority",children:"Attacks and Countermeasures page"}),". The vast majority of sub-slots will have more than 16 blocks (recall that the average number is targeted to be 32), therefore the minimum-block requirement will not have much of an affect on normal operation."]}),"\n",(0,n.jsxs)("figure",{children:[(0,n.jsx)("img",{src:"/img/deficit.png",alt:"drawing"}),(0,n.jsx)("figcaption",{children:(0,n.jsx)(t.p,{children:"Figure 10: c2 is the end of the sub-slot but not the end of the slot (we have yet to reach 0 deficit). c2 does NOT point to ic2, since the slot did not end at this sub-slot.\nDeficit is 3 instead of resetting to 16, and the infused challenge chain continues."})})]}),"\n",(0,n.jsx)(t.h2,{id:"weight",children:"Weight"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.strong,{children:"weight"})," of a block is the sum of the difficulty of this block, plus all previous blocks that are ancestors of this block. Honest full nodes must choose the peak of the blockchain such that the peak is the block with the heaviest weight that they know of. This is a crucial requirement, and is identical to Bitcoin's heaviest chain rule. Due to this rule, an attacker with less than 50% of the space and no VDF advantage will have trouble earning more than their fair share, since they must get lucky and create more reward chain blocks than the honest chain. Furthermore, farmers only farm on the challenges that correspond to the heaviest chain."]}),"\n",(0,n.jsx)(t.p,{children:"Both VDF speed and total amount of space are important for weight, and changes in these can trigger difficulty adjustments. If the amount of space increases, more than 32 blocks per slot will be created, so the difficulty has to be increased. If the network VDF speed increases, more than 32 blocks are created every 10 minutes, and thus the difficulty (and the sub-slot iterations) has to be increased."}),"\n",(0,n.jsx)(t.p,{children:"A farmer with exclusive access to a slightly faster VDF, however, cannot easily get more rewards than a farmer with the normal speed VDF. If an attacker tries to orphan one of the blocks on the chain, having a faster VDF will not help, since the attacker's chain will have fewer blocks (and thus a lower weight). Farmers must sign the block which they are building on top of, and they will only build on top of the highest weight chain."}),"\n",(0,n.jsxs)(t.p,{children:["The VDF speed comes into play when the attacker wishes to launch a 51% attack, however. In this case, an attacking farmer can use the VDF to create a completely alternate chain with no honest blocks, and overtake the honest chain. This requires 42.7% of the total netspace, since the faster VDF chain can obtain weight at a faster rate than the honest chain. This attack is described in detail in the ",(0,n.jsx)(t.a,{href:"/consensus-attacks#faster-timelord",children:"Attacks and Countermeasures page"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>r,a:()=>a});var n=s(7294);const i={},o=n.createContext(i);function a(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);