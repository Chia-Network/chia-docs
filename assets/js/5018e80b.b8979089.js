"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[550],{3223:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>h,toc:()=>c});var s=n(4848),i=n(8453);const o={title:"Three VDF Chains",slug:"/three-vdf-chains"},a=void 0,h={id:"consensus/three-vdf-chains",title:"Three VDF Chains",description:"If we only used one VDF (for the reward chain), the inclusion or exclusion of blocks would allow control of the challenge for the next slot. This means that an attacker could try many different combinations of blocks, and choose the challenge that suits them best, to obtain more wins in the next slot.",source:"@site/docs/consensus/three-vdf-chains.md",sourceDirName:"consensus",slug:"/three-vdf-chains",permalink:"/three-vdf-chains",draft:!1,unlisted:!1,editUrl:"https://github.com/Chia-Network/chia-docs/blob/main/docs/consensus/three-vdf-chains.md",tags:[],version:"current",frontMatter:{title:"Three VDF Chains",slug:"/three-vdf-chains"},sidebar:"tutorialSidebar",previous:{title:"Multiple Blocks",permalink:"/consensus-multiple-blocks"},next:{title:"Overflow Blocks and Weight",permalink:"/overflow-blocks"}},l={},c=[{value:"Definitions",id:"definitions",level:2}];function r(e){const t={a:"a",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"If we only used one VDF (for the reward chain), the inclusion or exclusion of blocks would allow control of the challenge for the next slot. This means that an attacker could try many different combinations of blocks, and choose the challenge that suits them best, to obtain more wins in the next slot."}),"\n",(0,s.jsxs)(t.p,{children:["These types of attacks are called grinding attacks, and they are one of the main difficulties of changing from Proof of Work to Proof of Space or Proof of Stake. More detail is provided in the ",(0,s.jsx)(t.a,{href:"/consensus-attacks",children:"Attacks and Countermeasures page"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"To mitigate this, the challenges will be based only on the first block to be infused in a slot."}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:"/img/multiple-chains.png",alt:"drawing"}),(0,s.jsxs)("figcaption",{children:[(0,s.jsx)(t.p,{children:"Figure 8: The three VDF chains for 1+ challenges."}),(0,s.jsx)(t.p,{children:"cc = challenge chain, ic = infused challenge chain, rc = reward chain,"}),(0,s.jsx)(t.p,{children:"sp = signage point, B = block, c = challenge, r = reward"}),(0,s.jsx)(t.p,{children:"An attacker can manipulate the reward chain results but this has no effect on c2, and therefore has no effect on the PoSpace lottery."})]})]}),"\n",(0,s.jsx)(t.p,{children:"There is a lot going on in this diagram! Let's break it down."}),"\n",(0,s.jsxs)(t.p,{children:["There are 4 ",(0,s.jsx)(t.strong,{children:"blocks"}),": B1, B2, B3, and B4. Farmers create these blocks. The blocks have pointers (the arrows), and the data the pointers are pointing to is all contained within the blocks themselves. At least 16 blocks have been created in the diagram's sub-slot, but we don't draw all of them due to space constraints."]}),"\n",(0,s.jsx)(t.p,{children:"The challenge chain and the reward chain each create 64 signage points, released every 9.375 seconds (on average) by timelords. Blocks must include the signage point VDFs (which mark the signage points) for both chains."}),"\n",(0,s.jsx)(t.p,{children:"The timelords send their VDF output to their full node, which adds it into an EndOfSubSlotBundle. This bundle includes the output from each chain (for example c1, ic1, and r1 in the diagram). The bundle is propagated to all other full nodes. Blocks must also include the infusion point VDFs for all three chains."}),"\n",(0,s.jsx)(t.p,{children:'The challenge chain broadcasts the challenges (c1 and c2). The same chain also executes the VDF from the start of the sub-slot to the end with nothing infused into it (the circles are VDF proofs but they do not interrupt the VDF). That is, in the challenge chain, the "lottery" is completely pre-determined, and not affected by blocks in the slot, until the end of the slot.'}),"\n",(0,s.jsx)(t.p,{children:"The reward chain infuses every block that is included."}),"\n",(0,s.jsxs)(t.p,{children:["The chain in the middle is called the ",(0,s.jsx)(t.strong,{children:"infused challenge chain"}),". It starts at the first infused block for each challenge, and goes on until the end of the slot."]}),"\n",(0,s.jsxs)(t.p,{children:["Recall that a ",(0,s.jsx)(t.strong,{children:"slot"})," must have at least 16 reward-chain blocks. A sub-slot doesn't have a minimum number of blocks (though it targets 32 blocks). Instead, a sub-slot always ends when sub-slot_iterations has been reached (this is targeted to take 10 minutes)."]}),"\n",(0,s.jsxs)(t.p,{children:["Because a sub-slot is targeted to produce more than 16 blocks, a slot usually only needs one sub-slot to meet its minimum-block requirement, but that is not always the case. For example, we may have only 10 blocks in a sub-slot, and then 3 and then 7, which means those three sub-slots form one slot. The ",(0,s.jsx)(t.strong,{children:"deficit"})," is the number of blocks still necessary to end the slot: this is described in more detail in the ",(0,s.jsx)(t.a,{href:"/overflow-blocks#minimum-block-requirement",children:"Overflow Blocks and Weight page"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"At the end of the slot, the challenge chain is combined with the infused challenge chain to generate the new challenge c2, which is used to start the challenge chain for the next sub-slot."}),"\n",(0,s.jsx)(t.p,{children:'The only block which affects the challenge chain (and thus the PoSpace lottery) is the first block in the slot, which here is B1. In fact, it\'s only a deterministic part of B1 called "cc B1", which only depends on challenge chain data. An attacker who wants to grind cannot change the challenge by withholding B2, B3, or any other block apart from the first one.'}),"\n",(0,s.jsx)(t.p,{children:"An honest farmer who holds the first block (B1) will release it. If an attacker controls the first block (B1), they have two additional options: delay it or withhold it."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Delay it: In order to know whether the new challenge will benefit them, they will need to execute the VDF all the way up to c2. By that time, their chance to get included in the reward chain is gone, since honest farmers sign only one block per proof of space."}),"\n",(0,s.jsx)(t.li,{children:"Withhold it: This does not provide much benefit to the attacker, since they must release it before sp2 in order to get the farmers on their chain. Farmers will choose the heaviest chain, which is the one with the most (heaviest) reward chain blocks."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'Why do we commit to any blocks at all in the challenge chain? If we did not, an attacker with a faster VDF could look ahead, since they would not need the help of honest participants in order to compute the challenge chain into the future. The challenge chain would be totally deterministic. This would enable some advantage by replotting. Furthermore, the challenge chain can be used to probabilistically prove the weight of the reward chain to light clients, without sharing all reward chain blocks (since the challenge chain depends on the "best" block in the slot, you can calculate the number of reward chain blocks).'}),"\n",(0,s.jsx)(t.p,{children:"For a block to be considered valid, it has to provide VDFs for the challenge chain and reward chain, and optionally for the infused challenge chain if it is present. Forcing all VDFs to be included means that all three chains are guaranteed to move forward at the same rate."}),"\n",(0,s.jsx)(t.h2,{id:"definitions",children:"Definitions"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Challenge chain"}),": The VDF chain based on each challenge for each sub-slot, which does not infuse anything in the middle of each sub-slot. The challenges are also used for the proofs of space. The signage points in this chain are used for the SP filter."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Reward chain"}),": The VDF chain that contains infusions of all blocks. This chain pulls in the challenge chain, and optionally, the infused challenge chain at the end of each sub-slot."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Infused challenge chain"}),": A VDF chain which starts at the first block infused in a slot (which is not based on the previous slot's challenge, this is called the challenge block) and ends at the end of the slot.\nThis increases security by preventing VDF lookahead attacks."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Sub-slot"}),": a period of time for which a timelord must run a VDF. The number of calculations the timelord must perform (sub-slot_iterations) to complete the sub-slot are adjusted periodically (and automatically) to take around 10 minutes. During this time, 64 signage points will be released and the entire network will submit an average of 32 valid proofs of space."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Slot"}),": one or more sub-slots. The important thing to remember is that a slot requires at least 16 reward-chain blocks. If these blocks are not produced in the first sub-slot, then another sub-slot will be required within the same slot. At the end of the slot, the infused challenge chain stops, the challenge chain pulls in the result of the infused challenge chain, and the deficit is reset to 16."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Block"}),": a block is a collection of data infused into the rewards chain which contains: a proof of space for a challenge hash with fewer iterations than the slot iterations, signage point and infusion point VDFs for both chains, optional infusion point VDF for the infused challenge chain, and a rewards address. Some blocks are also transaction blocks. There is a maximum of 128 blocks per slot."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Transaction Block"}),": A block that is eligible to create transactions, along with an associated list of transactions."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Challenge block"}),": The first block to be infused in each slot, which is not based on a previous slot's challenge. The challenge block always has a deficit of 15, and always starts off the infused challenge chain."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Peak"}),": The peak of the blockchain as seen by a node is the block with the greatest weight. Weight is the sum of the difficulty of a block and all its ancestors, which is similar to height, but a shorter chain can have heavier weight, due to difficulty adjustments."]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>h});var s=n(6540);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function h(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);