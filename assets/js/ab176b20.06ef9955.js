"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[7832],{2130:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>h});var t=i(4848),l=i(8453);const s={title:"Block Validation",slug:"/block-validation"},o=void 0,a={id:"block-validation/block-validation",title:"Block Validation",description:"Block validation in Chia is composed of two parts: header validation and body validation.",source:"@site/docs/block-validation/block-validation.md",sourceDirName:"block-validation",slug:"/block-validation",permalink:"/block-validation",draft:!1,unlisted:!1,editUrl:"https://github.com/Chia-Network/chia-docs/blob/main/docs/block-validation/block-validation.md",tags:[],version:"current",frontMatter:{title:"Block Validation",slug:"/block-validation"},sidebar:"tutorialSidebar",previous:{title:"Epoch and Difficulty",permalink:"/epoch-and-difficulty"},next:{title:"Light Clients",permalink:"/light-clients"}},c={},h=[{value:"Full Sync vs Normal Operation",id:"full-sync-vs-normal-operation",level:2},{value:"Full Sync",id:"full-sync",level:3},{value:"Normal Operation",id:"normal-operation",level:3},{value:"Block Validation Steps",id:"block-validation-steps",level:2},{value:"Header Validation",id:"header-validation",level:3},{value:"Body Validation",id:"body-validation",level:3}];function r(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Block validation in Chia is composed of two parts: header validation and body validation."}),"\n",(0,t.jsx)(n.p,{children:"The header validation performs consensus algorithm-related checks, such as proof of space and time, signage points and infusion points, previous block hashes, foliage hashes, and timestamps. Notably, it does not validate any CLVM, coin spends, or signatures. Usually, for efficiency, light clients will want to validate headers but not the body."}),"\n",(0,t.jsx)(n.p,{children:"Body validation entails running all puzzles for spent coins, reading the coin database, verifying signatures, checking for duplicate or invalid removals and additions, etc."}),"\n",(0,t.jsxs)(n.p,{children:["Validating a block in Chia will require access to some blocks in the past, up to a maximum theoretical value of three times the max number of blocks in a slot (3x128=384), but usually only a few are needed. Also, information regarding previous sub-epochs and epochs is needed for validation, as well as the current system timestamp. Implementations\ncan cache only some recent blocks instead of storing all blocks in memory. ",(0,t.jsx)(n.code,{children:"chia-blockchain"})," maintains a database of BlockRecords, which contain only the important pieces of block information required for validating future blocks."]}),"\n",(0,t.jsx)(n.h2,{id:"full-sync-vs-normal-operation",children:"Full Sync vs Normal Operation"}),"\n",(0,t.jsx)(n.p,{children:"There are two cases when a node might verify blocks."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"During a full sync, where the node is trying to catch up to the most recent block, starting from an old block height. In this case, the node is able to download many blocks at once."}),"\n",(0,t.jsx)(n.li,{children:"During normal operation, where the node is caught up to the most recent block, and is only downloading one block every few seconds."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"We'll cover both of these cases below."}),"\n",(0,t.jsx)(n.h3,{id:"full-sync",children:"Full Sync"}),"\n",(0,t.jsx)(n.p,{children:"Full sync is the process by which a full node downloads and validates all of the blocks in the blockchain and catches up to the most recent block. Full sync is important, because it allows new nodes to validate that a blockchain is the heaviest -- and thus, the currently valid -- chain. It allows everyone to come to consensus on the current state, regardless of when they come online, or for how long they go offline."}),"\n",(0,t.jsx)(n.p,{children:"The method of full sync can vary between implementations, but the high level algorithm is the following:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Connect to other peers on the network, by querying the DNS introducer, and crawling the network."}),"\n",(0,t.jsx)(n.li,{children:"Check the current weight of the peak of the peers, and select a few peers to sync from."}),"\n",(0,t.jsx)(n.li,{children:"Download and validate a weight proof, to ensure that the given peak has real work behind it."}),"\n",(0,t.jsx)(n.li,{children:"Download and validate all blocks in the blockchain, in batches."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Weight proofs are important, because they prevent other peers from lying to us about what the heaviest peak is. They also prevent us from downloading potentially useless data. Once the full node is caught up to the blockchain, it can properly farm, access the coin state, etc."}),"\n",(0,t.jsx)(n.h3,{id:"normal-operation",children:"Normal Operation"}),"\n",(0,t.jsx)(n.p,{children:"Normal operation is the process by which a full node continuously gossips and receives blocks with other peers, always following the heaviest peak. If our node is at weight 2000, and we see that a peer has a peak at weight 2100, then we fetch that block from the peer. Usually, this is done in two phases:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The unfinished block is propagated across the network, along with all information up to the signage point, transactions, etc."}),"\n",(0,t.jsx)(n.li,{children:"The finished block, which includes infusion point VDFs, is also propagated. This typically excludes the transactions, which were already sent in step 1."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Normal operation is much less CPU-intensive than full sync, since there is only one block every 18 seconds, and one transaction block every 52 seconds, on average. Low-power machines like the Raspberry PI 4 should be able to easily continue normal operation."}),"\n",(0,t.jsx)(n.h2,{id:"block-validation-steps",children:"Block Validation Steps"}),"\n",(0,t.jsxs)(n.p,{children:["The following sections list all of the required checks to ensure validity of a block. Please note that the official protocol and specification are defined by the ",(0,t.jsx)(n.code,{children:"chia-blockchain"}),"\n",(0,t.jsx)(n.a,{href:"https://github.com/Chia-Network/chia-blockchain/tree/main/chia/consensus",children:"reference implementation"}),", and not by this documentation page."]}),"\n",(0,t.jsx)(n.h3,{id:"header-validation",children:"Header Validation"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Check that the previous block exists in the blockchain, or that it is genesis."}),"\n",(0,t.jsxs)(n.li,{children:["Check finished slots that have been crossed since ",(0,t.jsx)(n.code,{children:"prev_b"}),"= the previous block in the chain.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Check sub-slot challenge hash for genesis block."}),"\n",(0,t.jsx)(n.li,{children:"Check sub-slot challenge hash for non-genesis block."}),"\n",(0,t.jsx)(n.li,{children:"Check sub-slot challenge hash for empty slot."}),"\n",(0,t.jsx)(n.li,{children:"Validate that genesis block has no ICC=Infused challenge chain."}),"\n",(0,t.jsx)(n.li,{children:"Validate that there is not icc iff icc_challenge hash is None."}),"\n",(0,t.jsx)(n.li,{children:"Check infused challenge chain sub-slot VDF."}),"\n",(0,t.jsx)(n.li,{children:"Check infused challenge sub-slot hash in challenge chain, deficit 16."}),"\n",(0,t.jsx)(n.li,{children:"Check infused challenge sub-slot hash not included for other deficits."}),"\n",(0,t.jsx)(n.li,{children:"Check infused challenge sub-slot hash in reward sub-slot."}),"\n",(0,t.jsx)(n.li,{children:"If no icc, check that the cc=challenge chain doesn't include it."}),"\n",(0,t.jsx)(n.li,{children:"If no icc, check that the rc=reward chain doesn't include it."}),"\n",(0,t.jsx)(n.li,{children:"Check sub-epoch summary hash is None for empty slots."}),"\n",(0,t.jsx)(n.li,{children:"Check new difficulty and ssi if applicable."}),"\n",(0,t.jsx)(n.li,{children:"Check new difficulty and ssi are None if we don't finish epoch."}),"\n",(0,t.jsx)(n.li,{children:"Check challenge sub-slot hash in reward sub-slot."}),"\n",(0,t.jsx)(n.li,{children:"Check end of reward slot VDF."}),"\n",(0,t.jsx)(n.li,{children:"Check challenge chain sub-slot VDF."}),"\n",(0,t.jsx)(n.li,{children:"Check deficit (MIN_SUB.. deficit edge case for genesis block)"}),"\n",(0,t.jsx)(n.li,{children:"If prev sb had deficit 0, resets deficit to MIN_BLOCK_PER_CHALLENGE_BLOCK"}),"\n",(0,t.jsx)(n.li,{children:"Otherwise, deficit stays the same at the slot ends, cannot reset until 0"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Check sub-epoch summary","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Check that genesis block does not have sub-epoch summary"}),"\n",(0,t.jsx)(n.li,{children:"Check that we finished a slot and we finished a sub-epoch"}),"\n",(0,t.jsx)(n.li,{children:"Check the actual sub-epoch is correct"}),"\n",(0,t.jsx)(n.li,{children:"Check that we don't have to include a sub-epoch summary"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Check if the number of blocks is less than the max"}),"\n",(0,t.jsx)(n.li,{children:"Check proof of space"}),"\n",(0,t.jsx)(n.li,{children:"Check signage point index"}),"\n",(0,t.jsx)(n.li,{children:"Check required iters"}),"\n",(0,t.jsx)(n.li,{children:"check signage point index 0 has no cc sp and no rc sp"}),"\n",(0,t.jsx)(n.li,{children:"Check no overflows in the first sub-slot of a new epoch"}),"\n",(0,t.jsx)(n.li,{children:"Check total iters"}),"\n",(0,t.jsx)(n.li,{children:"Check reward chain sp proof"}),"\n",(0,t.jsx)(n.li,{children:"Check reward chain sp signature"}),"\n",(0,t.jsx)(n.li,{children:"Check cc sp vdf"}),"\n",(0,t.jsx)(n.li,{children:"Check cc sp sig"}),"\n",(0,t.jsx)(n.li,{children:"Check is_transaction_block"}),"\n",(0,t.jsx)(n.li,{children:"Check foliage block signature by plot key"}),"\n",(0,t.jsx)(n.li,{children:"Check foliage block signature by plot key"}),"\n",(0,t.jsx)(n.li,{children:"Check unfinished reward chain block hash"}),"\n",(0,t.jsx)(n.li,{children:"Check pool target max height"}),"\n",(0,t.jsxs)(n.li,{children:["Check pre-farm puzzle hashes for genesis block.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If pospace has a pool pk, check pool target signature. Should not check this for genesis block."}),"\n",(0,t.jsx)(n.li,{children:"Otherwise, the plot is associated with a contract puzzle hash, not a public key, so check pool contract ph"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Check extension data if applicable. None for mainnet."}),"\n",(0,t.jsx)(n.li,{children:"Check if foliage block is present"}),"\n",(0,t.jsx)(n.li,{children:"Check foliage block hash"}),"\n",(0,t.jsx)(n.li,{children:"Check prev block hash for genesis and non-genesis"}),"\n",(0,t.jsx)(n.li,{children:"The filter hash in the Foliage Block must be the hash of the filter"}),"\n",(0,t.jsx)(n.li,{children:"The timestamp in Foliage Block must not be over 5 minutes in the future, and the timestamp must be greater than the previous transaction block timestamp"}),"\n",(0,t.jsx)(n.li,{children:"Check block height for genesis and non-genesis"}),"\n",(0,t.jsx)(n.li,{children:"Check block weight for genesis and non-genesis"}),"\n",(0,t.jsx)(n.li,{children:"Check challenge chain infusion point VDF"}),"\n",(0,t.jsx)(n.li,{children:"Check reward chain infusion point VDF"}),"\n",(0,t.jsx)(n.li,{children:"Check infused challenge chain infusion point VDF"}),"\n",(0,t.jsx)(n.li,{children:"Check reward block hash"}),"\n",(0,t.jsx)(n.li,{children:"Check reward block is_transaction_block"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"body-validation",children:"Body Validation"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"For non transaction-blocs: foliage block, transaction filter, transactions info, and generator must\nbe empty. If it is a block but not a transaction block, there is no body to validate. Check that all fields are\nNone, and return."}),"\n",(0,t.jsx)(n.li,{children:"For blocks, foliage block, transactions info must not be empty."}),"\n",(0,t.jsx)(n.li,{children:"The transaction info hash in the Foliage block must match the transaction info."}),"\n",(0,t.jsx)(n.li,{children:"The foliage block hash in the foliage block must match the foliage block."}),"\n",(0,t.jsx)(n.li,{children:"The reward claims must be valid for the previous blocks, and current block fees."}),"\n",(0,t.jsx)(n.li,{children:"No transactions before INITIAL_TRANSACTION_FREEZE timestamp (this check has been removed)."}),"\n",(0,t.jsx)(n.li,{children:"The generator root must be the hash of the serialized bytes of the generator for this block (or zeroes if no generator)"}),"\n",(0,t.jsxs)(n.li,{children:["Check the transactions generator reference list:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The generator_ref_list must be the hash of the serialized bytes of"}),"\n",(0,t.jsx)(n.li,{children:"the generator ref list for this block (or 'one' bytes [0x01] if no generator)"}),"\n",(0,t.jsx)(n.li,{children:"The generator ref list length must be less than or equal to MAX_GENERATOR_REF_LIST_SIZE entries"}),"\n",(0,t.jsx)(n.li,{children:"The generator ref list must not point to a height >= this block's height"}),"\n",(0,t.jsx)(n.li,{children:"If we have a generator reference list, we must have a generator"}),"\n",(0,t.jsx)(n.li,{children:"Check that cost <= MAX_BLOCK_COST_CLVM"}),"\n",(0,t.jsx)(n.li,{children:"The CLVM program must not return any errors"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Check that the correct cost is in the transactions info"}),"\n",(0,t.jsx)(n.li,{children:"Check additions for max coin amount (be careful to check for 64 bit overflows in other languages. This is the max 64 bit unsigned integer)"}),"\n",(0,t.jsx)(n.li,{children:"Validate addition and removal merkle set roots."}),"\n",(0,t.jsx)(n.li,{children:"The additions and removals must result in the correct filter."}),"\n",(0,t.jsx)(n.li,{children:"Check for duplicate outputs in additions."}),"\n",(0,t.jsx)(n.li,{children:"Check for duplicate spends inside block."}),"\n",(0,t.jsx)(n.li,{children:"Check if removals exist and were not previously spent. (coin_db up to the fork point + fork block + this_block).\nBe careful with forks and with ephemeral coins (added and removed in same block)."}),"\n",(0,t.jsx)(n.li,{children:"Check that the total coin amount for added is <= removed."}),"\n",(0,t.jsx)(n.li,{children:"Check that the assert fee sum <= fees, and that each reserved fee is non-negative."}),"\n",(0,t.jsx)(n.li,{children:"Check that the fee amount + farmer reward < maximum coin amount."}),"\n",(0,t.jsx)(n.li,{children:"Check that the computed fees are equal to the fees in the block header."}),"\n",(0,t.jsx)(n.li,{children:"Verify that removed coin puzzle_hashes match with calculated puzzle_hashes."}),"\n",(0,t.jsx)(n.li,{children:"Verify CLVM conditions."}),"\n",(0,t.jsx)(n.li,{children:"Verify aggregated signature."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(r,{...e})}):r(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const l={},s=t.createContext(l);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);